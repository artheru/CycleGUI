<!doctype html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/>
	<title>CycleGUI WebUI</title>
	<style>
      body {
        font-family: arial;
        margin: 0;
        padding: none;
			overflow:hidden;
      }
        canvas {
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        .emscripten {
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            touch-action: none;
		
            width: 100%;
            height: 100%;
        }
      div.emscripten { text-align: center; }
      div.emscripten_border { border: none; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { 
          position:absolute; border: 0px none; background-color: black;
      }

        #textinput { /*hidden proxy*/
            position: absolute;
            top: 100px;
            background-color: #ffffff00;
            color: #ffffff00;
            border: none;
            width: 10px;
        }
    </style>
	<style>
        .lds-ellipsis {
            /* change color here */
            color: #1c4c5b
        }

            .lds-ellipsis,
            .lds-ellipsis div {
                box-sizing: border-box;
            }

        .lds-ellipsis {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 80px;
        }

            .lds-ellipsis div {
                position: absolute;
                top: 33.33333px;
                width: 13.33333px;
                height: 13.33333px;
                border-radius: 50%;
                background: currentColor;
                animation-timing-function: cubic-bezier(0, 1, 1, 0);
            }

                .lds-ellipsis div:nth-child(1) {
                    left: 8px;
                    animation: lds-ellipsis1 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(2) {
                    left: 8px;
                    animation: lds-ellipsis2 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(3) {
                    left: 32px;
                    animation: lds-ellipsis2 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(4) {
                    left: 56px;
                    animation: lds-ellipsis3 0.6s infinite;
                }

        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(0);
            }
        }

        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(24px, 0);
            }
        } 
	</style>
</head>
<body>
    
<script type="text/javascript">
    const cc = document.createElement('canvas');
    const context = cc.getContext('2d', { willReadFrequently: true });

    function drawChar(char) {
    // Set the font and size for the drawing context
        const fontSize = 16;
        const font = `${fontSize}px Georgia SimSun serif`; // Replace Georgia with any font family you prefer;

        context.font = font;
        const str = String.fromCodePoint(char);
        const textMetrics = context.measureText(str);
        const width = Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft);
        const height = Math.ceil(textMetrics.fontBoundingBoxAscent - textMetrics.fontBoundingBoxDescent); // Set height to font size to ensure enough space

        if (width < 1) return 0;
        
        // Resize the canvas to fit the glyph dimensions
        cc.width = width;
        cc.height = height;
        context.clearRect(0, 0, width, height);
        context.fillStyle = 'black';
        context.font = font;
        context.textBaseline = 'bottom';
        context.fillText(str, 0, height);

        const imageData = context.getImageData(0, 0, width, height);

        if (/\p{Emoji}/u.test(str)) { //emoji.
            let ret = new Uint8Array(imageData.data.length + 16);
            let dataView = new DataView(ret.buffer);
            dataView.setInt32(0, width, true);
            dataView.setInt32(4, height, true);
            dataView.setInt32(8, -height * 0.85, true); //offset Y
            dataView.setInt32(12, textMetrics.width, true); //advance X
            ret.set(imageData.data, 16);

            return ret;
        } else { // normal chars
            let ret = new Uint8Array(imageData.data.length + 16);
            let dataView = new DataView(ret.buffer);
            dataView.setInt32(0, -width, true);
            dataView.setInt32(4, height, true);
            dataView.setInt32(8, -height * 0.85, true); //offset Y
            dataView.setInt32(12, textMetrics.width, true); //advance X
            ret.set(imageData.data, 16);

            return ret;
        }
    }
</script>
<div id="loader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); justify-content: center; align-items: center; text-align:center;/* or adjust as needed */">
    <div id="stage">Loading CycleGUI Assemblies</div><br/>
    <span id="detail"></span><br />
    <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
</div>
<div class="emscripten_border">
	<canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
</div>

<script>
    function loaderMsg(str) {
        document.getElementById("stage").innerHTML = "Loading Components:";
        document.getElementById("detail").innerHTML = str;
    }
    let ccmain = document.getElementById('canvas');
    ccmain.style.visibility = "hidden";
</script>

	<input type="text" id="textinput" style="position: absolute; top: -100px;"
	       autocomplete="new-password" autocorrect="off" autocapitalize="off" spellcheck="false"> <!-- maybe use proxy to input text.-->
	</input>

    <script type="text/js-worker">
        let socket;

        onmessage = function(event) {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    socket = new WebSocket(message.url);
                    console.log(`Start Connection to ${message.url}`);
                    socket.binaryType = 'arraybuffer';

                    socket.onopen = function() {
                        postMessage({ event: 'open' });
                    };

                    socket.onmessage = function(e) {
                        let now = new Date();
                        //console.log(`[${now.getSeconds()}.${now.getMilliseconds()}] wsworker sz=${e.data.byteLength}`);
                        const receivedData = new Uint8Array(e.data); // Process the binary data as required
                        postMessage({ event: 'message', data: receivedData });
                    };

                    socket.onerror = function(error) {
                        postMessage({ event: 'error', error: error.message });
                    };

                    socket.onclose = function(e) {
                        postMessage({ event: 'close', code: e.code });
                    };
                    break;

                case 'send':
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(message.data);
                    } else {
                        postMessage({ event: 'error', error: 'Socket is not open for sending.' });
                    }
                    break;

                case 'close':
                    if (socket) {
                        socket.close();
                    }
                    break;
            }
        };
    </script>

    <script type='text/javascript'>
        var proxyinput = document.getElementById("textinput");

        var c_ontouch = () => { };

        // Function to handle touch events
        function touch_event_fired(touches) {
            // Create a Float32Array to hold the touch data
            let caching = new Uint8Array(touches.length * 2 * 4);
            let dataView = new DataView(caching.buffer);
            for (let i = 0; i < touches.length; ++i) {
                dataView.setInt32((i * 2) * 4, touches[i].x, true);
                dataView.setInt32((i * 2 + 1) * 4, touches[i].y, true);
            }
            c_ontouch(caching, touches.length);
        }

        // Function to extract touch positions
        function getTouchPositions(touchList) {
            let positions = [];
            for (let i = 0; i < touchList.length; i++) {
                positions.push({ x: touchList[i].clientX, y: touchList[i].clientY });
            }
            return positions;
        }

        // Touch event listeners
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        function handleTouchMove(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        function handleTouchEnd(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        // Attach listeners to the document or a specific element
        document.addEventListener('touchstart', handleTouchStart, { passive: false, capture: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: false, capture: true });
        document.addEventListener('touchend', handleTouchEnd, { passive: false, capture: true });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false, capture: true });

        function hookTouches() {
            c_ontouch = Module.cwrap('ontouch', // name of C function
                null, // return type
                ['array', 'number']); // argument types
        }

        function getParameterByName(name) {
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(window.location.href);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }
        var portValue = getParameterByName('port');

        // Check if the parameter was found and display it
        if (portValue !== null) {
            window.wsport = parseInt(portValue);
        } else {
            window.wsport = 8081;
        }

        // generate a ws worker.
        var terminalDataUrl = 'ws://' + window.location.hostname + ':' + window.wsport + '/terminal/data';
        const blob = new Blob(
            Array.prototype.map.call(
                document.querySelectorAll("script[type='text\/js-worker']"),
                (script) => script.textContent,
            ),
            { type: "text/javascript" },
        );
        websocketWorker = new Worker(window.URL.createObjectURL(blob));

        // Function to send binary data via Web Worker
        function sendBinaryToServer(data) {
            websocketWorker.postMessage({ command: 'send', data: data });
        }

        var socket;
        function getTimestampSMS() {
            let now = new Date();
            return now.getSeconds() + now.getMilliseconds() * 0.001;
        }

        function connect2server() {
            // absolutely safe to wrap any functions exported by emscripten.
            hookTouches();
            var c_onmessage = Module.cwrap('onmessage', // name of C function
                null, // return type
                ['array', 'number']); // argument types
            //console.log(`Notify Connection to ${terminalDataUrl}`);
            websocketWorker.postMessage({ command: 'initialize', url: terminalDataUrl });
            websocketWorker.onmessage = function (e) {
                const message = e.data;
                switch (message.event) {
                    case 'open':
                        console.log("WebSocket connection established via Web Worker.");
                        socket = true;
                        break;
                    case 'message':
                        c_onmessage(message.data, message.data.length);
                        break;
                    case 'error':
                        console.error("WebSocket error:", message.error);
                        socket = false;
                        break;
                    case 'close':
                        console.log("WebSocket closed with code:", message.code);
                        socket = false;
                        break;
                }
            };
        }

        var dpr = window.devicePixelRatio;
        function isMobile() {
            return /Mobi|Android/i.test(navigator.userAgent);
        }
        if (isMobile()) {
            console.log("Mobile device detected");
            dpr = 1;
        }


        window.addEventListener('resize', js_resizeCanvas, false);
        function js_resizeCanvas() {
            let cc = document.getElementById('canvas');
            cc.width = window.innerWidth * dpr;
            cc.height = window.innerHeight * dpr;
        }

        var Module = {
            preRun: [],
            postRun: [],
            print: (function () {
                text = Array.prototype.slice.call(arguments).join(' ');
            })(),
            printErr: function (text) {
                text = Array.prototype.slice.call(arguments).join(' ');
            },
            printErr: function (text) { },
            canvas: (function () {
                var canvas = document.getElementById('canvas');
                // As a default initial behavior, pop up an alert when webgl context is lost. To make your
                // application robust, you may want to override this behavior before shipping!
                // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
                canvas.addEventListener("webglcontextlost", function (e) {
                    alert('WebGL context lost. You will need to reload the page.');
                    e.preventDefault();
                }, false);
                return canvas;
            })(),
            setStatus: function (text) { },
            totalDependencies: 0,
            monitorRunDependencies: function (left) { }
        };
    </script>
    {{{ SCRIPT }}}
</body>
</html>