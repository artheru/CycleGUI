<!doctype html>
<html lang="en-us">
<head>
    <title>placeholder1</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
    <style>
        body {
            font-family: arial;
            margin: 0;
            padding: none;
            overflow: hidden;
        }

        canvas {
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        .emscripten {
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        div.emscripten {
            text-align: center;
        }

        div.emscripten_border {
            border: none;
        }
        /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
        canvas.emscripten {
            position: absolute;
            border: 0px none;
            background-color: black;
        }

        #textinput { /*hidden proxy*/
            position: absolute;
            top: 100px;
            background-color: #ffffff00;
            color: #ffffff00;
            border: none;
            width: 10px;
        }

        /* H5 Window Styles */
        .h5-window {
            position: fixed;
            width: 80%;
            height: 80%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: column;
            z-index: 1000;
            left: 10%;
            top: 10%;
            min-width: 200px;
            min-height: 150px;
            user-select: none;
        }

        .h5-window-resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: transparent;
            z-index: 1001;
        }

        .h5-window-resize-handle.nw {
            top: 0;
            left: 0;
            cursor: nw-resize;
            width: 20px;
            height: 20px;
        }

        .h5-window-resize-handle.ne {
            top: 0;
            right: 0;
            cursor: ne-resize;
            width: 20px;
            height: 20px;
        }

        .h5-window-resize-handle.sw {
            bottom: 0;
            left: 0;
            cursor: sw-resize;
            width: 20px;
            height: 20px;
        }

        .h5-window-resize-handle.se {
            bottom: 0;
            right: 0;
            cursor: se-resize;
            width: 20px;
            height: 20px;
        }

        .h5-window-resize-handle.n {
            top: 0;
            left: 0;
            width: 100%;
            height: 8px;
            cursor: n-resize;
        }

        .h5-window-resize-handle.s {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            cursor: s-resize;
        }

        .h5-window-resize-handle.e {
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            cursor: e-resize;
        }

        .h5-window-resize-handle.w {
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            cursor: w-resize;
        }

        .h5-window.visible {
            display: flex;
        }

        .h5-window-titlebar {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: #f5f5f5;
            border-radius: 8px 8px 0 0;
            cursor: move;
            user-select: none;
        }

        .h5-window-title {
            flex: 1;
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .h5-window-controls {
            display: flex;
            gap: 8px;
        }

        .h5-window-button {
            width: 24px;
            height: 24px;
            border: none;
            background: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .h5-window-button:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .h5-window-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .h5-window-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .h5-window-iframe.active {
            pointer-events: auto;
        }

        .h5-window-open-new {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.1);
            color: #333;
            text-decoration: none;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1002;
        }

        .h5-window-open-new:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* SVG Icons */
        .icon-minimize {
            width: 12px;
            height: 12px;
            background: #ffbd2e;
        }

        .icon-maximize {
            width: 12px;
            height: 12px;
            background: #28c940;
        }

        .icon-close {
            width: 12px;
            height: 12px;
            background: #ff5f56;
        }
    </style>
    <style>
        .lds-ellipsis {
            /* change color here */
            color: #1c4c5b
        }

            .lds-ellipsis,
            .lds-ellipsis div {
                box-sizing: border-box;
            }

        .lds-ellipsis {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 80px;
        }

            .lds-ellipsis div {
                position: absolute;
                top: 33.33333px;
                width: 13.33333px;
                height: 13.33333px;
                border-radius: 50%;
                background: currentColor;
                animation-timing-function: cubic-bezier(0, 1, 1, 0);
            }

                .lds-ellipsis div:nth-child(1) {
                    left: 8px;
                    animation: lds-ellipsis1 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(2) {
                    left: 8px;
                    animation: lds-ellipsis2 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(3) {
                    left: 32px;
                    animation: lds-ellipsis2 0.6s infinite;
                }

                .lds-ellipsis div:nth-child(4) {
                    left: 56px;
                    animation: lds-ellipsis3 0.6s infinite;
                }

        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(0);
            }
        }

        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(24px, 0);
            }
        }
    </style>
</head>
<body>
<script>
    // fuck emsdk change:
    function getModuleAsm() {
        if (typeof wasmExports != "undefined")
            return wasmExports;  
        return Module.asm;
    }
</script>
<script>
        // Step 1: Retrieve the favicon URL
        const faviconUrl = document.querySelector('link[rel="icon"]').href;

        // Step 2: Create an Image object and load the favicon
        const image = new Image();
        image.crossOrigin = "Anonymous"; // Allow CORS if needed
        image.src = faviconUrl;

        var favui8arr = 0;
        var favicosz = 0;

        image.onload = function () {
            // Step 3: Draw the image onto a Canvas
            const canvas = document.createElement('canvas');
            if (image.width == 0) {
                favicosz = -1;
                return;
            }
            canvas.width = 48;
            canvas.height = 48; // force equal size.
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

            // Step 4: Extract RGBA data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const rgbaData = imageData.data;

            // Step 5: Convert to Uint8Array
            const uint8Array = new Uint8Array(rgbaData);
            favicosz = image.width;
            favui8arr = uint8Array;
        };
        image.onerror = function () {
            favicosz = -1;
        }
    </script>
<script id="streamworker" type="text/js-worker">
        onmessage = async function(event) {
            const canvas = new OffscreenCanvas(1, 1);
            const ctx = canvas.getContext('2d');
            const url = event.data.url;
            const response = await fetch(url);
            const reader = response.body.getReader();
            const sa = event.data.sharedArray;

            async function processStream() {
                let buffer = new Uint8Array();
                let headerEndIndex = -1;
                let contentLength = -1;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // Append new data to buffer
                    let newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;

                    // Look for header end (\r\n\r\n)
                    if (headerEndIndex == -1)
                        for (let i = 0; i < buffer.length - 3; i++) {
                            if (buffer[i] === 13 && buffer[i + 1] === 10 && buffer[i + 2] === 13 && buffer[i + 3] === 10) {
                                headerEndIndex = i + 4;
                                let headers = new TextDecoder('utf-8').decode(buffer.slice(0, headerEndIndex));
                                let contentLengthMatch = headers.match(/Content-Length: (\d+)/);
                                contentLength = parseInt(contentLengthMatch[1], 10);
                                break;
                            }
                        }

                    if (headerEndIndex !== -1) {
                        // Check if we have all the content
                        if (buffer.length >= headerEndIndex + contentLength) {
                            let imageStartIndex = headerEndIndex;
                            let imageEndIndex = imageStartIndex + contentLength;
                            let imageData = buffer.slice(imageStartIndex, imageEndIndex);

                            // Create ImageBitmap from Blob
                            let blob = new Blob([imageData], {type: 'image/jpeg'});
                            let imageBitmap = await createImageBitmap(blob);

                            // Draw on canvas and send data back
                            canvas.width = imageBitmap.width;
                            canvas.height = imageBitmap.height;
                            ctx.drawImage(imageBitmap, 0, 0);

                            let arr = ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
                            let rgba = arr.data;

                            for (let i = 0; i < rgba.length; i += 4) {
                                sa[i] = rgba[i + 2];     // B
                                sa[i + 1] = rgba[i + 1]; // G
                                sa[i + 2] = rgba[i];     // R
                                sa[i + 3] = rgba[i + 3]; // A
                            }

                            // Move buffer to the start of the next part
                            buffer = buffer.slice(imageEndIndex);
                            headerEndIndex = -1; // Reset header end index
                        }
                    }
                }
            }
            processStream();
        };
    </script>


<script>
            // real time streamer.
        function stream(name, ptr, w, h) {
        
            const url = 'stream/' + name;
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const img = new Image();
        
            function fetchStream() {
                img.src = url;
                img.onload = () => {
                    fetchStream(); // Fetch the next frame
                    ctx.drawImage(img, 0, 0, w, h);
                    let arr = ctx.getImageData(0, 0, w, h);
                    Module.HEAPU8.set(arr.data, ptr);
                };
                img.onerror = () => {
                    setTimeout(fetchStream, 300); // Retry after 300ms
                };
            }
            fetchStream();
        
        }
    </script>
<script>
        function jsDownload(filehash, pid, fname) {
            const url = `filelink?fid=${filehash}&pid=${pid}`;
            const controller = new AbortController();
            const { signal } = controller;
            let dl = { stopped: false };

            // Create the modal and progress elements
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.left = '0';
            modal.style.top = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '1000';
            modal.style.transition = "opacity 1s ease";

            const progressContainer = document.createElement('div');
            progressContainer.style.width = '50%';
            progressContainer.style.padding = '20px';
            progressContainer.style.backgroundColor = '#fff';
            progressContainer.style.borderRadius = '5px';
            progressContainer.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
            progressContainer.style.textAlign = 'center';
            progressContainer.style.fontFamily = 'Arial, sans-serif';
            progressContainer.style.color = '#333';

            const progressBar = document.createElement('div');
            progressBar.style.width = '0%';
            progressBar.style.height = '20px';
            progressBar.style.backgroundColor = '#4CAF50';
            progressBar.style.borderRadius = '5px';
            progressBar.style.transition = 'width 0.3s ease';

            const stopButton = document.createElement('button');
            stopButton.innerText = 'Stop Downloading';
            stopButton.style.padding = '10px 20px';
            stopButton.style.fontSize = '16px';
            stopButton.style.cursor = 'pointer';
            stopButton.style.border = 'none';
            stopButton.style.borderRadius = '5px';
            stopButton.style.backgroundColor = '#f44336';
            stopButton.style.color = 'white';
            stopButton.style.marginTop = '20px';
            stopButton.onclick = function () {
                dl.stopped = true;
                controller.abort();
                modal.remove();
            };

            const progressText = document.createElement('div');
            progressText.style.marginTop = '10px';
            progressText.innerText = "Starting download";
            progressContainer.appendChild(progressBar);
            progressContainer.appendChild(progressText);
            progressContainer.appendChild(stopButton);
            modal.appendChild(progressContainer);
            document.body.appendChild(modal);


            // Utility function to format bytes into the most suitable unit
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';

                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            // Start fetching the file
            fetch(url, { signal })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                })
                .then(response => {
                    const reader = response.body.getReader();
                    const contentLength = +response.headers.get('Content-Length');
                    let receivedLength = 0; // received that many bytes at the moment
                    let chunks = []; // array of received binary chunks (comprises the body)

                    // Read the data
                    let startTime = Date.now();
                    return reader.read().then(function processResult(result) {
                        if (result.done) {
                            modal.style.opacity = 0;
                            setTimeout(() => { modal.remove() }, 1000); // Download completed, remove the modal

                            const blob = new Blob(chunks, { type: 'application/octet-stream' });
                            const downloadUrl = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = downloadUrl;
                            a.download = fname;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            URL.revokeObjectURL(downloadUrl);
                            return;
                        }

                        chunks.push(result.value);
                        receivedLength += result.value.length;

                        // Update progress bar and text
                        let percent = (receivedLength / contentLength * 100).toFixed(2);
                        progressBar.style.width = `${percent}%`;
                        let elapsedTime = (Date.now() - startTime) / 1000;
                        let speed = (receivedLength / elapsedTime).toFixed(2);
                        progressText.innerText = `Downloaded ${formatBytes(receivedLength)} of ${formatBytes(contentLength)} (${formatBytes(speed)}/sec)`;

                        // Call read() again for the next chunk
                        return reader.read().then(processResult);
                    });
                })
                .catch(error => {
                    modal.remove();
                    if (!dl.stopped)
                        alert(`Download failed: ${error.message}`);
                });
        }
    </script>

<script type="text/javascript">
        const cc = document.createElement('canvas');
        const context = cc.getContext('2d', { willReadFrequently: true });

        function drawChar(char) {
            // Set the font and size for the drawing context
            const fontSize = 16;
            const font = `${fontSize}px Georgia SimSun serif`; // Replace Georgia with any font family you prefer;

            context.font = font;
            const str = String.fromCodePoint(char);
            const textMetrics = context.measureText(str);
            const width = Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft);
            const height = Math.ceil(textMetrics.fontBoundingBoxAscent - textMetrics.fontBoundingBoxDescent); // Set height to font size to ensure enough space

            if (width < 1) return 0;

            // Resize the canvas to fit the glyph dimensions
            cc.width = width;
            cc.height = height;
            context.clearRect(0, 0, width, height);
            context.fillStyle = 'black';
            context.font = font;
            context.textBaseline = 'bottom';
            context.fillText(str, 0, height);

            const imageData = context.getImageData(0, 0, width, height);

            if (/\p{Emoji}/u.test(str)) { //emoji.
                let ret = new Uint8Array(imageData.data.length + 16);
                let dataView = new DataView(ret.buffer);
                dataView.setInt32(0, width, true);
                dataView.setInt32(4, height, true);
                dataView.setInt32(8, -height * 0.85, true); //offset Y
                dataView.setInt32(12, textMetrics.width, true); //advance X
                ret.set(imageData.data, 16);

                return ret;
            } else { // normal chars
                let ret = new Uint8Array(imageData.data.length + 16);
                let dataView = new DataView(ret.buffer);
                dataView.setInt32(0, -width, true);
                dataView.setInt32(4, height, true);
                dataView.setInt32(8, -height * 0.85, true); //offset Y
                dataView.setInt32(12, textMetrics.width, true); //advance X
                ret.set(imageData.data, 16);

                return ret;
            }
        }
    </script>
<div id="loader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); justify-content: center; align-items: center; text-align:center;/* or adjust as needed */">
	<div id="stage">Loading placeholder1 Assemblies</div><br/>
	<span id="detail"></span><br/>
	<div class="lds-ellipsis">
		<div></div>
		<div></div>
		<div></div>
		<div></div>
	</div>
</div>
<div class="emscripten_border">
	<canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
</div>

<script>
        function loaderMsg(str) {
            document.getElementById("stage").innerHTML = "Loading Components:";
            document.getElementById("detail").innerHTML = str;
        }
        let ccmain = document.getElementById('canvas');
        ccmain.style.visibility = "hidden";
    </script>

<input type="text" id="textinput" style="position: absolute; top: -100px;"
       autocomplete="new-password" autocorrect="off" autocapitalize="off" spellcheck="false"> <!-- maybe use proxy to input text.-->
</input>

<script id="wsworker" type="text/js-worker">
        let socket;

        onmessage = function(event) {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    socket = new WebSocket(message.url);
                    console.log(`Start Connection to ${message.url}`);
                    socket.binaryType = 'arraybuffer';

                    socket.onopen = function() {
                        postMessage({ event: 'open' });
                    };

                    socket.onmessage = function(e) {
                        let now = new Date();
                        //console.log(`[${now.getSeconds()}.${now.getMilliseconds()}] wsworker sz=${e.data.byteLength}`);
                        const receivedData = new Uint8Array(e.data); // Process the binary data as required
                        postMessage({ event: 'message', data: receivedData });
                    };

                    socket.onerror = function(error) {
                        postMessage({ event: 'error', error: error.message });
                    };

                    socket.onclose = function(e) {
                        postMessage({ event: 'close', code: e.code });
                    };
                    break;

                case 'send':
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(message.data);
                        postMessage({ event: 'sent' });
                    } else {
                        postMessage({ event: 'error', error: 'Socket is not open for sending.' });
                    }
                    break;

                case 'close':
                    if (socket) {
                        socket.close();
                    }
                    break;
            }
        };
    </script>

<script type='text/javascript'>
        var proxyinput = document.getElementById("textinput");

        var c_ontouch = () => { };

        // Function to handle touch events
        function touch_event_fired(touches) {
            // Create a Float32Array to hold the touch data
            let caching = new Uint8Array(touches.length * 3 * 4);
            let dataView = new DataView(caching.buffer);
            for (let i = 0; i < touches.length; ++i) {
                dataView.setInt32((i * 3) * 4, touches[i].identifier, true);
                dataView.setInt32((i * 3 + 1) * 4, touches[i].x, true);
                dataView.setInt32((i * 3 + 2) * 4, touches[i].y, true);
            }
            c_ontouch(caching, touches.length);
        }

        // Function to extract touch positions
        function getTouchPositions(touchList) {
            let positions = [];
            for (let i = 0; i < touchList.length; i++) {
                positions.push({ x: touchList[i].clientX, y: touchList[i].clientY });
            }
            return positions;
        }

        // Touch event listeners
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        function handleTouchMove(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        function handleTouchEnd(event) {
            event.preventDefault(); // Prevent default behavior
            event.stopImmediatePropagation();
            let positions = getTouchPositions(event.touches);
            touch_event_fired(positions);
        }

        // Attach listeners to the document or a specific element
        document.addEventListener('touchstart', handleTouchStart, { passive: false, capture: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: false, capture: true });
        document.addEventListener('touchend', handleTouchEnd, { passive: false, capture: true });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false, capture: true });

        function hookTouches() {
            c_ontouch = Module.cwrap('ontouch', // name of C function
                null, // return type
                ['array', 'number']); // argument types
        }

        // generate a ws worker.
        // var terminalDataUrl = 'ws://' + window.location.host + '/terminal/data';
        var path = window.location.pathname;
        var terminalDataUrl;

        // Get the directory part by removing the filename
        let directoryPath = window.location.pathname.substring(0, path.lastIndexOf('/'));
        // Now override for root or debug cases
        if (directoryPath === '/' || directoryPath === '/debug') {
            terminalDataUrl = 'ws://' + window.location.host + '/terminal/data';
        } else {
            terminalDataUrl = 'ws://' + window.location.host + directoryPath + '/terminal/data';
        }


        const blob = new Blob([document.getElementById("wsworker").textContent], { type: "text/javascript" });
        websocketWorker = new Worker(window.URL.createObjectURL(blob));

        // Function to send binary data via Web Worker
        var sent = false;
        function sendBinaryToServer(data) {
            sent = false;
            websocketWorker.postMessage({ command: 'send', data: data });
        }

        var socket;
        function getTimestampSMS() {
            let now = new Date();
            return now.getSeconds() + now.getMilliseconds() * 0.001;
        }

        function connect2server() {
            // absolutely safe to wrap any functions exported by emscripten.
            hookTouches();
            var c_onmessage = Module.cwrap('onmessage', // name of C function
                null, // return type
                ['array', 'number']); // argument types
            //console.log(`Notify Connection to ${terminalDataUrl}`);
            websocketWorker.postMessage({ command: 'initialize', url: terminalDataUrl });
            websocketWorker.onmessage = function (e) {
                const message = e.data;
                switch (message.event) {
                    case 'open':
                        console.log("WebSocket connection established via Web Worker.");
                        socket = true;
                        break;
                    case 'sent':
                        sent = true;
                        break;
                    case 'message':
                        c_onmessage(message.data, message.data.length);
                        break;
                    case 'error':
                        console.error("WebSocket error:", message.error);
                        socket = false;
                        break;
                    case 'close':
                        console.log("WebSocket closed with code:", message.code);
                        socket = false;
                        break;
                }
            };
        }

        var dpr = window.devicePixelRatio;
        function isMobile() {
            return /Mobi|Android/i.test(navigator.userAgent);
        }
        if (isMobile()) {
            console.log("Mobile device detected");
            dpr = 1;
        }


        window.addEventListener('resize', js_resizeCanvas, false);
        function js_resizeCanvas() {
            let cc = document.getElementById('canvas');
            cc.width = window.innerWidth * dpr;
            cc.height = window.innerHeight * dpr;
        }

        const appName = "placeholder1";
        const defaultImGUILayoutIni = "placeholder2";

        var Module = {
            preRun: [],
            postRun: [],
            print: (function () {
                text = Array.prototype.slice.call(arguments).join(' ');
            })(),
            printErr: function (text) {
                text = Array.prototype.slice.call(arguments).join(' ');
            },
            printErr: function (text) { },
            canvas: (function () {
                var canvas = document.getElementById('canvas');
                // As a default initial behavior, pop up an alert when webgl context is lost. To make your
                // application robust, you may want to override this behavior before shipping!
                // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
                canvas.addEventListener("webglcontextlost", function (e) {
                    alert('WebGL context lost. You will need to reload the page.');
                    e.preventDefault();
                }, false);
                return canvas;
            })(),
            setStatus: function (text) { },
            totalDependencies: 0,
            monitorRunDependencies: function (left) { }
        };
    </script>

    <!-- H5 Window -->
<div class="h5-window" id="h5Window">
    <div class="h5-window-titlebar" id="h5WindowTitlebar">
        <div class="h5-window-title">
            <a class="h5-window-open-new" id="h5WindowOpenNew" target="_blank">🔗</a>
            <span id="h5WindowTitle" style=" left: 36px; position: relative; ">Web View</span>
        </div>
        <div class="h5-window-controls">
            <button class="h5-window-button" id="h5WindowMinimize">
                <div class="icon-minimize"></div>
            </button>
            <button class="h5-window-button" id="h5WindowMaximize">
                <div class="icon-maximize"></div>
            </button>
            <button class="h5-window-button" id="h5WindowClose">
                <div class="icon-close"></div>
            </button>
        </div>
    </div>
    <div class="h5-window-content">
        <iframe class="h5-window-iframe" id="h5WindowIframe"></iframe>
    </div>
    <div class="h5-window-resize-handle n"></div>
    <div class="h5-window-resize-handle e"></div>
    <div class="h5-window-resize-handle s"></div>
    <div class="h5-window-resize-handle w"></div>
    <div class="h5-window-resize-handle ne"></div>
    <div class="h5-window-resize-handle se"></div>
    <div class="h5-window-resize-handle sw"></div>
    <div class="h5-window-resize-handle nw"></div>
</div>

    <script>
        // H5 Window functionality
        const h5Window = document.getElementById('h5Window');
        const h5WindowTitlebar = document.getElementById('h5WindowTitlebar');
        const h5WindowIframe = document.getElementById('h5WindowIframe');
        const h5WindowOpenNew = document.getElementById('h5WindowOpenNew');
        const h5WindowTitle = document.getElementById('h5WindowTitle');
        const h5WindowMinimize = document.getElementById('h5WindowMinimize');
        const h5WindowMaximize = document.getElementById('h5WindowMaximize');
        const h5WindowClose = document.getElementById('h5WindowClose');
        const resizeHandles = document.querySelectorAll('.h5-window-resize-handle');

        let isDragging = false;
        let isResizing = false;
        let isMaximized = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        let originalWidth;
        let originalHeight;
        let originalX;
        let originalY;
        let resizeDirection = '';
        let iframeActive = false;

        // Store original dimensions
        function storeOriginalDimensions() {
            originalWidth = h5Window.offsetWidth;
            originalHeight = h5Window.offsetHeight;
            const rect = h5Window.getBoundingClientRect();
            originalX = rect.left;
            originalY = rect.top;
        }

        // Initialize position offsets when window is shown
        function initializePositionOffsets() {
            const rect = h5Window.getBoundingClientRect();
            xOffset = rect.left;
            yOffset = rect.top;
            currentX = xOffset;
            currentY = yOffset;
            initialX = 0;
            initialY = 0;
        }

        // Prevent text selection during resize
        function preventSelection(e) {
            e.preventDefault();
            return false;
        }

        // Resize functionality
        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', initResize);
        });

        function initResize(e) {
            isResizing = true;
            resizeDirection = e.target.className.split(' ')[1];
            initialX = e.clientX;
            initialY = e.clientY;
            storeOriginalDimensions();
            
            // Disable iframe interaction during resize
            h5WindowIframe.classList.remove('active');
            
            // Prevent text selection
            document.body.style.userSelect = 'none';
            document.addEventListener('selectstart', preventSelection);
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function resize(e) {
            if (!isResizing) return;
            
            e.preventDefault();
            const deltaX = e.clientX - initialX;
            const deltaY = e.clientY - initialY;
            
            let newWidth = originalWidth;
            let newHeight = originalHeight;
            let newX = originalX;
            let newY = originalY;

            // Handle different resize directions
            if (resizeDirection.includes('e')) {
                newWidth = Math.max(200, originalWidth + deltaX);
            }
            if (resizeDirection.includes('w')) {
                const widthDelta = Math.min(deltaX, originalWidth - 200);
                newWidth = originalWidth - widthDelta;
                newX = originalX + widthDelta;
            }
            if (resizeDirection.includes('s')) {
                newHeight = Math.max(150, originalHeight + deltaY);
            }
            if (resizeDirection.includes('n')) {
                const heightDelta = Math.min(deltaY, originalHeight - 150);
                newHeight = originalHeight - heightDelta;
                newY = originalY + heightDelta;
            }

            // Apply new dimensions
            h5Window.style.width = `${newWidth}px`;
            h5Window.style.height = `${newHeight}px`;
            h5Window.style.left = `${newX}px`;
            h5Window.style.top = `${newY}px`;
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
            
            // Re-enable text selection
            document.body.style.userSelect = '';
            document.removeEventListener('selectstart', preventSelection);
            
            // Re-enable iframe interaction after a short delay
            setTimeout(() => {
                if (iframeActive) {
                    h5WindowIframe.classList.add('active');
                }
            }, 100);
        }

        // Existing drag functionality
        h5WindowTitlebar.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (e.target === h5WindowTitlebar || e.target.parentElement === h5WindowTitlebar) {
                isDragging = true;
                
                // Disable iframe interaction during drag
                h5WindowIframe.classList.remove('active');
                
                if (isMaximized) {
                    isMaximized = false;
                    h5Window.style.width = originalWidth + 'px';
                    h5Window.style.height = originalHeight + 'px';
                    h5Window.style.left = originalX + 'px';
                    h5Window.style.top = originalY + 'px';
                    
                    // Re-initialize position after un-maximizing
                    initializePositionOffsets();
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;

                const maxX = window.innerWidth - h5Window.offsetWidth;
                const maxY = window.innerHeight - h5Window.offsetHeight;
                
                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));

                xOffset = currentX;
                yOffset = currentY;
                
                h5Window.style.left = currentX + 'px';
                h5Window.style.top = currentY + 'px';
            }
        }

        function dragEnd(e) {
            if (isDragging) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                
                // Re-enable iframe interaction after a short delay
                setTimeout(() => {
                    if (iframeActive) {
                        h5WindowIframe.classList.add('active');
                    }
                }, 100);
            }
        }

        // Handle iframe focus - use mousedown/up events instead of enter/leave
        h5WindowIframe.addEventListener('mousedown', () => {
            if (!isDragging && !isResizing) {
                iframeActive = true;
                h5WindowIframe.classList.add('active');
            }
        });
        
        document.addEventListener('mousedown', (e) => {
            // If clicking outside the iframe but inside the window content
            if (e.target !== h5WindowIframe && !h5WindowIframe.contains(e.target) && 
                h5Window.contains(e.target) && e.target !== h5WindowTitlebar && 
                !h5WindowTitlebar.contains(e.target) && 
                !e.target.classList.contains('h5-window-resize-handle')) {
                iframeActive = false;
                h5WindowIframe.classList.remove('active');
            }
        });

        h5WindowMinimize.addEventListener('click', () => {
            h5Window.style.display = 'none';
        });

        h5WindowMaximize.addEventListener('click', () => {
            if (!isMaximized) {
                storeOriginalDimensions();
                h5Window.style.width = '100%';
                h5Window.style.height = '100%';
                h5Window.style.left = '0';
                h5Window.style.top = '0';
                isMaximized = true;
            } else {
                h5Window.style.width = originalWidth + 'px';
                h5Window.style.height = originalHeight + 'px';
                h5Window.style.left = originalX + 'px';
                h5Window.style.top = originalY + 'px';
                isMaximized = false;
            }
        });

        h5WindowClose.addEventListener('click', () => {
            h5Window.style.display = 'none';
            isMaximized = false;
        });

        // Function to show H5 window with URL
        window.showH5Window = function(url) {
            h5WindowIframe.src = url;
            h5WindowOpenNew.href = url;
            h5WindowTitle.textContent = url;
            h5Window.style.display = 'flex';
            
            if (!isMaximized) {
                h5Window.style.width = '80%';
                h5Window.style.height = '80%';
                h5Window.style.left = '10%';
                h5Window.style.top = '10%';
                h5Window.style.transform = 'none';
            }
            
            // Initialize position tracking after setting position
            setTimeout(() => {
                initializePositionOffsets();
                storeOriginalDimensions();
            }, 0);
        };
    </script>
{{{ SCRIPT }}}
</body>
</html>