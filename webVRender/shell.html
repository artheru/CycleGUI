<!doctype html>
<html lang="en-us">
<head>
    <title>placeholder1</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
    <style>
        body {
            font-family: arial;
            margin: 0;
            padding: none;
            overflow: hidden;
        }

        /* WebSocket reconnect status */
        #wsStatus {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 2000;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 12px;
            display: none;
            user-select: none;
            pointer-events: none;
        }

        canvas {
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        .emscripten {
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        div.emscripten {
            text-align: center;
        }

        div.emscripten_border {
            border: none;
        }
        /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
        canvas.emscripten {
            position: absolute;
            border: 0px none;
            background-color: black;
        }

        #textinput { /*hidden proxy*/
            position: absolute;
            top: 100px;
            background-color: #ffffff00;
            color: #ffffff00;
            border: none;
            width: 10px;
        }

        /* H5 Window Styles */
        .h5-window {
            position: fixed;
            width: 80%;
            height: 80%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: column;
            z-index: 1000;
            left: 10%;
            top: 10%;
            min-width: 200px;
            min-height: 150px;
            user-select: none;
        }

        .h5-window-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1001;
        }
        .h5-window-resize-handle.nw, .h5-window-resize-handle.ne, 
        .h5-window-resize-handle.sw, .h5-window-resize-handle.se { width: 20px; height: 20px; }
        .h5-window-resize-handle.nw, .h5-window-resize-handle.ne { top: 0; }
        .h5-window-resize-handle.sw, .h5-window-resize-handle.se { bottom: 0; }
        .h5-window-resize-handle.nw, .h5-window-resize-handle.sw { left: 0; }
        .h5-window-resize-handle.ne, .h5-window-resize-handle.se { right: 0; }
        .h5-window-resize-handle.nw { cursor: nw-resize; }
        .h5-window-resize-handle.ne { cursor: ne-resize; }
        .h5-window-resize-handle.sw { cursor: sw-resize; }
        .h5-window-resize-handle.se { cursor: se-resize; }
        .h5-window-resize-handle.n, .h5-window-resize-handle.s { width: 100%; height: 8px; }
        .h5-window-resize-handle.e, .h5-window-resize-handle.w { height: 100%; width: 8px; }
        .h5-window-resize-handle.n { top: 0; left: 0; cursor: n-resize; }
        .h5-window-resize-handle.s { bottom: 0; left: 0; cursor: s-resize; }
        .h5-window-resize-handle.e { top: 0; right: 0; cursor: e-resize; }
        .h5-window-resize-handle.w { top: 0; left: 0; cursor: w-resize; }

        .h5-window.visible {
            display: flex;
        }

        .h5-window-titlebar {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: #f5f5f5;
            border-radius: 8px 8px 0 0;
            cursor: move;
            user-select: none;
        }

        .h5-window-title {
            flex: 1;
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .h5-window-controls {
            display: flex;
            gap: 8px;
        }

        .h5-window-button {
            width: 24px;
            height: 24px;
            border: none;
            background: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .h5-window-button:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .h5-window-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .h5-window-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .h5-window-iframe.active {
            pointer-events: auto;
        }

        .h5-window-open-new {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.1);
            color: #333;
            text-decoration: none;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1002;
        }

        .h5-window-open-new:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* SVG Icons */
        .icon-minimize, .icon-maximize, .icon-close { width: 12px; height: 12px; }
        .icon-minimize { background: #ffbd2e; }
        .icon-maximize { background: #28c940; }
        .icon-close { background: #ff5f56; }
    </style>
    <style>
        .lds-ellipsis, .lds-ellipsis div { box-sizing: border-box; }
        .lds-ellipsis { color: #1c4c5b; display: inline-block; position: relative; width: 80px; height: 80px; }
        .lds-ellipsis div { position: absolute; top: 33.33333px; width: 13.33333px; height: 13.33333px; 
            border-radius: 50%; background: currentColor; animation-timing-function: cubic-bezier(0, 1, 1, 0); }
        .lds-ellipsis div:nth-child(1) { left: 8px; animation: lds-ellipsis1 0.6s infinite; }
        .lds-ellipsis div:nth-child(2) { left: 8px; animation: lds-ellipsis2 0.6s infinite; }
        .lds-ellipsis div:nth-child(3) { left: 32px; animation: lds-ellipsis2 0.6s infinite; }
        .lds-ellipsis div:nth-child(4) { left: 56px; animation: lds-ellipsis3 0.6s infinite; }
        @keyframes lds-ellipsis1 { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        @keyframes lds-ellipsis3 { 0% { transform: scale(1); } 100% { transform: scale(0); } }
        @keyframes lds-ellipsis2 { 0% { transform: translate(0, 0); } 100% { transform: translate(24px, 0); } }
    </style>
</head>
<body>
<script>
    // fuck emsdk change:
    function getModuleAsm() {
        if (typeof wasmExports != "undefined")
            return wasmExports;  
        return Module.asm;
    }
</script>
<script>
        // Step 1: Retrieve the favicon URL
        const faviconUrl = document.querySelector('link[rel="icon"]').href;

        // Step 2: Create an Image object and load the favicon
        const image = new Image();
        image.crossOrigin = "Anonymous"; // Allow CORS if needed
        image.src = faviconUrl;

        var favui8arr = 0;
        var favicosz = 0;

        image.onload = function () {
            // Step 3: Draw the image onto a Canvas
            const canvas = document.createElement('canvas');
            if (image.width == 0) {
                favicosz = -1;
                return;
            }
            canvas.width = 48;
            canvas.height = 48; // force equal size.
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

            // Step 4: Extract RGBA data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const rgbaData = imageData.data;

            // Step 5: Convert to Uint8Array
            const uint8Array = new Uint8Array(rgbaData);
            favicosz = image.width;
            favui8arr = uint8Array;
        };
        image.onerror = function () {
            favicosz = -1;
        }
    </script>
<script id="streamworker" type="text/js-worker">
        onmessage = async function(event) {
            const canvas = new OffscreenCanvas(1, 1);
            const ctx = canvas.getContext('2d');
            const url = event.data.url;
            const response = await fetch(url);
            const reader = response.body.getReader();
            const sa = event.data.sharedArray;

            async function processStream() {
                let buffer = new Uint8Array();
                let headerEndIndex = -1;
                let contentLength = -1;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // Append new data to buffer
                    let newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;

                    // Look for header end (\r\n\r\n)
                    if (headerEndIndex == -1)
                        for (let i = 0; i < buffer.length - 3; i++) {
                            if (buffer[i] === 13 && buffer[i + 1] === 10 && buffer[i + 2] === 13 && buffer[i + 3] === 10) {
                                headerEndIndex = i + 4;
                                let headers = new TextDecoder('utf-8').decode(buffer.slice(0, headerEndIndex));
                                let contentLengthMatch = headers.match(/Content-Length: (\d+)/);
                                contentLength = parseInt(contentLengthMatch[1], 10);
                                break;
                            }
                        }

                    if (headerEndIndex !== -1) {
                        // Check if we have all the content
                        if (buffer.length >= headerEndIndex + contentLength) {
                            let imageStartIndex = headerEndIndex;
                            let imageEndIndex = imageStartIndex + contentLength;
                            let imageData = buffer.slice(imageStartIndex, imageEndIndex);

                            // Create ImageBitmap from Blob
                            let blob = new Blob([imageData], {type: 'image/jpeg'});
                            let imageBitmap = await createImageBitmap(blob);

                            // Draw on canvas and send data back
                            canvas.width = imageBitmap.width;
                            canvas.height = imageBitmap.height;
                            ctx.drawImage(imageBitmap, 0, 0);

                            let arr = ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
                            let rgba = arr.data;

                            for (let i = 0; i < rgba.length; i += 4) {
                                sa[i] = rgba[i + 2];     // B
                                sa[i + 1] = rgba[i + 1]; // G
                                sa[i + 2] = rgba[i];     // R
                                sa[i + 3] = rgba[i + 3]; // A
                            }

                            // Move buffer to the start of the next part
                            buffer = buffer.slice(imageEndIndex);
                            headerEndIndex = -1; // Reset header end index
                        }
                    }
                }
            }
            processStream();
        };
    </script>


<script>
            // real time streamer.
        function stream(name, ptr, w, h) {
        
            const url = 'stream/' + name;
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const img = new Image();
        
            function fetchStream() {
                img.src = url;
                img.onload = () => {
                    fetchStream(); // Fetch the next frame
                    ctx.drawImage(img, 0, 0, w, h);
                    let arr = ctx.getImageData(0, 0, w, h);
                    Module.HEAPU8.set(arr.data, ptr);
                };
                img.onerror = () => {
                    setTimeout(fetchStream, 300); // Retry after 300ms
                };
            }
            fetchStream();
        
        }
    </script>
<script>
        function jsDownload(filehash, pid, fname) {
            const url = `filelink?fid=${filehash}&pid=${pid}`;
            const controller = new AbortController();
            const { signal } = controller;
            let dl = { stopped: false };

            // Create the modal and progress elements
            const modal = document.createElement('div');
            Object.assign(modal.style, {
                position: 'fixed', left: '0', top: '0', width: '100%', height: '100%',
                backgroundColor: 'rgba(0, 0, 0, 0.7)', display: 'flex',
                justifyContent: 'center', alignItems: 'center', zIndex: '1000',
                transition: "opacity 1s ease"
            });

            const progressContainer = document.createElement('div');
            Object.assign(progressContainer.style, {
                width: '50%', padding: '20px', backgroundColor: '#fff',
                borderRadius: '5px', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
                textAlign: 'center', fontFamily: 'Arial, sans-serif', color: '#333'
            });

            const progressBar = document.createElement('div');
            Object.assign(progressBar.style, {
                width: '0%', height: '20px', backgroundColor: '#4CAF50',
                borderRadius: '5px', transition: 'width 0.3s ease'
            });

            const stopButton = document.createElement('button');
            stopButton.innerText = 'Stop Downloading';
            Object.assign(stopButton.style, {
                padding: '10px 20px', fontSize: '16px', cursor: 'pointer',
                border: 'none', borderRadius: '5px', backgroundColor: '#f44336',
                color: 'white', marginTop: '20px'
            });
            stopButton.onclick = function () {
                dl.stopped = true;
                controller.abort();
                modal.remove();
            };

            const progressText = document.createElement('div');
            progressText.style.marginTop = '10px';
            progressText.innerText = "Starting download";
            progressContainer.appendChild(progressBar);
            progressContainer.appendChild(progressText);
            progressContainer.appendChild(stopButton);
            modal.appendChild(progressContainer);
            document.body.appendChild(modal);


            // Utility function to format bytes into the most suitable unit
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';

                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            // Start fetching the file
            fetch(url, { signal })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                })
                .then(response => {
                    const reader = response.body.getReader();
                    const contentLength = +response.headers.get('Content-Length');
                    let receivedLength = 0; // received that many bytes at the moment
                    let chunks = []; // array of received binary chunks (comprises the body)

                    // Read the data
                    let startTime = Date.now();
                    return reader.read().then(function processResult(result) {
                        if (result.done) {
                            modal.style.opacity = 0;
                            setTimeout(() => { modal.remove() }, 1000); // Download completed, remove the modal

                            const blob = new Blob(chunks, { type: 'application/octet-stream' });
                            const downloadUrl = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = downloadUrl;
                            a.download = fname;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            URL.revokeObjectURL(downloadUrl);
                            return;
                        }

                        chunks.push(result.value);
                        receivedLength += result.value.length;

                        // Update progress bar and text
                        let percent = (receivedLength / contentLength * 100).toFixed(2);
                        progressBar.style.width = `${percent}%`;
                        let elapsedTime = (Date.now() - startTime) / 1000;
                        let speed = (receivedLength / elapsedTime).toFixed(2);
                        progressText.innerText = `Downloaded ${formatBytes(receivedLength)} of ${formatBytes(contentLength)} (${formatBytes(speed)}/sec)`;

                        // Call read() again for the next chunk
                        return reader.read().then(processResult);
                    });
                })
                .catch(error => {
                    modal.remove();
                    if (!dl.stopped)
                        alert(`Download failed: ${error.message}`);
                });
        }
    </script>

<script type="text/javascript">
        const cc = document.createElement('canvas');
        const context = cc.getContext('2d', { willReadFrequently: true });

        function drawChar(char) {
            // Set the font and size for the drawing context
            const fontSize = 16;
            const font = `${fontSize}px Georgia SimSun serif`; // Replace Georgia with any font family you prefer;

            context.font = font;
            const str = String.fromCodePoint(char);
            const textMetrics = context.measureText(str);
            const width = Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft);
            const height = Math.ceil(textMetrics.fontBoundingBoxAscent - textMetrics.fontBoundingBoxDescent); // Set height to font size to ensure enough space

            if (width < 1) return 0;

            // Resize the canvas to fit the glyph dimensions
            cc.width = width;
            cc.height = height;
            context.clearRect(0, 0, width, height);
            context.fillStyle = 'black';
            context.font = font;
            context.textBaseline = 'bottom';
            context.fillText(str, 0, height);

            const imageData = context.getImageData(0, 0, width, height);

            if (/\p{Emoji}/u.test(str)) { //emoji.
                let ret = new Uint8Array(imageData.data.length + 16);
                let dataView = new DataView(ret.buffer);
                dataView.setInt32(0, width, true);
                dataView.setInt32(4, height, true);
                dataView.setInt32(8, -height * 0.85, true); //offset Y
                dataView.setInt32(12, textMetrics.width, true); //advance X
                ret.set(imageData.data, 16);

                return ret;
            } else { // normal chars
                let ret = new Uint8Array(imageData.data.length + 16);
                let dataView = new DataView(ret.buffer);
                dataView.setInt32(0, -width, true);
                dataView.setInt32(4, height, true);
                dataView.setInt32(8, -height * 0.85, true); //offset Y
                dataView.setInt32(12, textMetrics.width, true); //advance X
                ret.set(imageData.data, 16);

                return ret;
            }
        }
    </script>
<div id="loader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); justify-content: center; align-items: center; text-align:center;/* or adjust as needed */">
	<div id="stage">Loading placeholder1 Assemblies</div><br/>
	<span id="detail"></span><br/>
	<div class="lds-ellipsis">
		<div></div>
		<div></div>
		<div></div>
		<div></div>
	</div>
</div>
<div id="wsStatus">reconnecting</div>
<div class="emscripten_border">
	<canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
</div>

<script>
        function loaderMsg(str) {
            document.getElementById("stage").innerHTML = "Loading Components:";
            document.getElementById("detail").innerHTML = str;
        }
        let ccmain = document.getElementById('canvas');
        ccmain.style.visibility = "hidden";
    </script>

<input type="text" id="textinput" style="position: absolute; top: -100px;"
       autocomplete="new-password" autocorrect="off" autocapitalize="off" spellcheck="false"> <!-- maybe use proxy to input text.-->
</input>

<script id="wsworker" type="text/js-worker">
        let socket=true;

        onmessage = function(event) {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    socket = new WebSocket(message.url);
                    console.log(`Start Connection to ${message.url}`);
                    socket.binaryType = 'arraybuffer';

                    socket.onopen = function() {
                        postMessage({ event: 'open' });
                    };

                    socket.onmessage = function(e) {
                        let now = new Date();
                        //console.log(`[${now.getSeconds()}.${now.getMilliseconds()}] wsworker sz=${e.data.byteLength}`);
                        const receivedData = new Uint8Array(e.data); // Process the binary data as required
                        postMessage({ event: 'message', data: receivedData });
                    };

                    socket.onerror = function(error) {
                        postMessage({ event: 'error', error: error.message });
                    };

                    socket.onclose = function(e) {
                        postMessage({ event: 'close', code: e.code });
                    };
                    break;

                case 'send':
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(message.data);
                        postMessage({ event: 'sent' });
                    } else {
                        postMessage({ event: 'error', error: 'Socket is not open for sending.' });
                    }
                    break;

                case 'close':
                    if (socket) {
                        socket.close();
                    }
                    break;
            }
        };
    </script>

<script type='text/javascript'>
    // patch for stupid emscripten glue.
    (function () {
        const origAdd = window.addEventListener;
        const origRemove = window.removeEventListener;

        function isGLFWKeydown(type, listener) { return type === 'keydown' && listener && listener.name === 'onKeydown'; }
        function isEditableTarget(t) {
            if (!t) return false;
            if (t.isContentEditable) return true;

            const tag = (t.tagName || "").toUpperCase();
            if (tag === "TEXTAREA") return !t.readOnly && !t.disabled;
            if (tag === "INPUT") {
                const type = (t.type || "").toLowerCase();
                const nonText = new Set([
                    "button", "checkbox", "color", "date", "datetime-local", "file",
                    "hidden", "image", "month", "radio", "range", "reset", "submit",
                    "time", "week"
                ]);
                return !nonText.has(type) && !t.readOnly && !t.disabled;
            }
            return false;
        }
        window.addEventListener = function (type, listener, options) {
            if (isGLFWKeydown(type, listener) && window.GLFW) {
                const wrapped = function (e) {
                    if ((e.key === 'Backspace' || e.key === 'Tab') && isEditableTarget(e.target)) return;
                    return listener(e);
                };
                listener.__wrapped = wrapped;
                return origAdd.call(this, type, wrapped, options);
            }
            return origAdd.call(this, type, listener, options);
        };

        window.removeEventListener = function (type, listener, options) {
            return origRemove.call(this, type, listener && listener.__wrapped ? listener.__wrapped : listener, options);
        };
    })();

    var c_ontouch = () => { };
    // ------------------------------------------------------------------
    // Web IME bridge helpers
    // ------------------------------------------------------------------
    (function () {
        const debug = false;
        const FLAG_TEXT_CHANGED = 1;
        const FLAG_REQUEST_HIDE = 4;
        const FLAG_TAB = 8;
        const FLAG_ENTER = 16;

        const imeElements = {};
        const imeState = {
            activeId: 0,
            element: null,
            type: 0,
            lastValue: "",
            composing: false,
            valueChanged: false,
            pendingFlags: 0,
            ignoreProgrammaticChange: false,
            lastSyncedValue: "",
        };

        function toCssColor(r, g, b, a)
        {
            const clamp255 = (v) => Math.round(Math.min(Math.max(v, 0), 1) * 255);
            return `rgba(${clamp255(r)}, ${clamp255(g)}, ${clamp255(b)}, ${Math.min(Math.max(a, 0), 1)})`;
        }

        function ensureElement(type) {
            if (imeElements[type]) return imeElements[type];

            const el = type === 2 ? Object.assign(document.createElement('input'), {type: 'password', autocomplete: 'off'})
                : Object.assign(document.createElement('textarea'), {rows: type === 1 ? 3 : 1});
            
            if (type !== 2) {
                el.setAttribute('wrap', 'off');
                Object.assign(el.style, {
                    resize: 'none',
                    whiteSpace: type === 1 ? 'pre-wrap' : 'pre',
                    overflow: type === 1 ? 'auto' : 'hidden'
                });
            }

            ['autocomplete', 'autocorrect', 'autocapitalize'].forEach(attr => el.setAttribute(attr, 'off'));
            el.setAttribute('spellcheck', 'false');
            Object.assign(el.style, {
                position: 'fixed', zIndex: '10000', backgroundColor: 'transparent',
                color: '#ffffff', caretColor: '#ffffff', outline: 'none', border: 'none',
                padding: '0px', margin: '0px', display: 'none', pointerEvents: 'auto',
                letterSpacing: 'normal', fontFamily: 'georgia', boxSizing: 'border-box'
            });

            el.addEventListener('compositionstart', () => {
                imeState.composing = true;
            });
            el.addEventListener('compositionend', () => {
                imeState.composing = false;
                imeState.valueChanged = true;
            });
            el.addEventListener('input', () => {
                if (imeState.ignoreProgrammaticChange) {
                    imeState.ignoreProgrammaticChange = false;
                    return;
                }
                imeState.valueChanged = true;
            });
            el.addEventListener('keydown', (ev) => {
                if (ev.key === 'Tab') {
                    ev.preventDefault();
                    imeState.pendingFlags |= (FLAG_TAB | FLAG_REQUEST_HIDE);
                    el.blur();
                } else if (ev.key === 'Enter' && imeState.type !== 1 && !ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
                    ev.preventDefault();
                    imeState.pendingFlags |= (FLAG_ENTER | FLAG_REQUEST_HIDE);
                    el.blur();
                }
            });
            el.addEventListener('blur', () => {
                if (imeState.element === el && el.value !== imeState.lastSyncedValue)
                    imeState.pendingFlags |= FLAG_TEXT_CHANGED;
                imeState.pendingFlags |= FLAG_REQUEST_HIDE;
            });

            document.body.appendChild(el);
            imeElements[type] = el;
            return el;
        }

        function hideActiveElement() {
            if (!imeState.element) return;
            const element = imeState.element;
            if (document.activeElement === element) try { element.blur(); } catch (_) {}
            element.style.display = 'none';
            Object.assign(imeState, {activeId: 0, element: null, type: 0, lastValue: "", 
                composing: false, valueChanged: false, pendingFlags: 0, 
                ignoreProgrammaticChange: false, lastSyncedValue: ""});
        }

        function codepointIndexFromUtf16(str, utf16Index) {
            if (!str || utf16Index <= 0)
                return 0;
            let count = 0;
            let i = 0;
            const len = Math.min(utf16Index, str.length);
            while (i < len) {
                const code = str.charCodeAt(i++);
                if (code >= 0xd800 && code <= 0xdbff && i < len) {
                    const next = str.charCodeAt(i);
                    if (next >= 0xdc00 && next <= 0xdfff)
                        i++;
                }
                count++;
            }
            return count;
        }

        const moduleRef = (typeof Module !== 'undefined') ? Module : (window.Module = window.Module || {});

        window.cycleGuiIme = moduleRef.cycleGuiIme = moduleRef.cycleGuiIme || {
            sync(id, type, x, y, w, h, lineHeight, fontSize, dpiScale, text, cursorCp, selStartCp, selEndCp, rounding, padX, padY, bgR, bgG, bgB, bgA, textR, textG, textB, textA) {
                if (imeState.activeId !== 0 && imeState.activeId !== id)
                    hideActiveElement();

                const element = ensureElement(type);
                const wasVisible = (imeState.element === element) && element.style.display !== 'none';
                const isNewActivation = (imeState.activeId !== id) || !wasVisible;

                imeState.activeId = id;
                imeState.element = element;
                imeState.type = type;

                const bgColor = toCssColor(bgR, bgG, bgB, bgA);
                const textColor = toCssColor(textR, textG, textB, textA);
                Object.assign(element.style, {
                    display: 'block', left: `${x}px`, top: `${y}px`,
                    width: `${Math.max(1, w)}px`, height: `${Math.max(1, h)}px`,
                    lineHeight: `${Math.max(1, lineHeight)}px`, fontSize: `${Math.max(1, fontSize-2)}px`,
                    borderRadius: `${Math.max(0, rounding)}px`,
                    padding: `${Math.max(0, padY)}px ${Math.max(0, padX)}px`,
                    backgroundColor: bgColor, color: textColor, caretColor: textColor,
                    border: '1px solid transparent', backgroundClip: 'padding-box'
                });
                if (type !== 2) Object.assign(element.style, {
                    whiteSpace: type === 1 ? 'pre-wrap' : 'pre',
                    overflow: type === 1 ? 'auto' : 'hidden',
                    resize: 'none'
                });

                if (isNewActivation) {
                    element.value = text;
                    imeState.lastValue = text;
                    imeState.lastSyncedValue = text;
                    imeState.valueChanged = false;
                    if (document.activeElement !== element) {
                        try {
                            element.focus({ preventScroll: true });
                        } catch (_) {
                            element.focus();
                        }
                    }
                }
            },

            poll(id) {
                if (imeState.activeId !== id || !imeState.element) 
                    return { flags: 0, text: "", cursor: 0, selStart: 0, selEnd: 0 };

                const el = imeState.element, text = el.value;
                const selStart = el.selectionStart ?? 0, selEnd = el.selectionEnd ?? selStart;
                
                let flags = imeState.pendingFlags; imeState.pendingFlags = 0;
                if (document.activeElement !== el && !imeState.composing) flags |= FLAG_REQUEST_HIDE;
                if ((flags & FLAG_REQUEST_HIDE) && text !== imeState.lastSyncedValue) flags |= FLAG_TEXT_CHANGED;
                
                imeState.lastValue = text; imeState.valueChanged = false;
                if (flags & FLAG_TEXT_CHANGED) imeState.lastSyncedValue = text;

                const result = {
                    flags, text,
                    cursor: codepointIndexFromUtf16(text, selEnd),
                    selStart: codepointIndexFromUtf16(text, selStart),
                    selEnd: codepointIndexFromUtf16(text, selEnd)
                };
                if (debug) console.log("[IME] poll", result);
                return result;
            },

            hide() {
                hideActiveElement();
                if (debug) console.log("[IME] hide");
            },

            flags: {
                TEXT_CHANGED: FLAG_TEXT_CHANGED,
                REQUEST_HIDE: FLAG_REQUEST_HIDE,
                TAB: FLAG_TAB,
                ENTER: FLAG_ENTER
            }
        };

        moduleRef.cycleGuiIme = window.cycleGuiIme;
    })();

    function hookTouches() {
        c_ontouch = Module.cwrap('ontouch', // name of C function
            null, // return type
            ['array', 'number']); // argument types
    }

    // Generate WebSocket URL
    const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const dirPath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
    const terminalDataUrl = wsScheme + window.location.host + 
        (['/', '/debug'].includes(dirPath) ? '' : dirPath) + '/terminal/data';


    // WebSocket worker will be (re)created on demand to support reconnect.
    var websocketWorker = null;

    // Function to send binary data via Web Worker
    var sent = false;
    function sendBinaryToServer(data) {
        sent = false;
        if (!websocketWorker) return;
        websocketWorker.postMessage({ command: 'send', data: data });
    }

    var socket;

    // ---- Reconnect controller state ----
    let explicitClosing = false;
    let reconnecting = false;
    let reconnectAttempt = 0;
    let reconnectTimer = null;
    let reconnectId = null;
    const wsStatusEl = document.getElementById('wsStatus');
    function setWsStatus(text, visible) {
        if (!wsStatusEl) return;
        wsStatusEl.textContent = text || '';
        wsStatusEl.style.display = visible ? 'block' : 'none';
    }
    window.cycleGuiIsReconnecting = () => reconnecting;

    function createWebsocketWorker() {
        const blob = new Blob([document.getElementById("wsworker").textContent], { type: "text/javascript" });
        return new Worker(window.URL.createObjectURL(blob));
    }

    async function ensureReconnectId() {
        if (reconnectId) return reconnectId;
        const resp = await fetch("terminal/session", { cache: "no-store" });
        const sid = (await resp.text()).trim();
        reconnectId = sid;
        return reconnectId;
    }

    function clearReconnectId() {
        reconnectId = null;
    }

    async function checkSessionAlive(sid) {
        try {
            const resp = await fetch(`terminal/check?reconnect=${encodeURIComponent(sid)}`, { cache: "no-store" });
            const txt = (await resp.text()).trim();
            return txt === "OK";
        } catch (_) {
            // transient network error: keep trying
            return true;
        }
    }

    function scheduleReconnect() {
        if (explicitClosing) return;
        if (reconnectTimer) return;
        reconnecting = true;
        setWsStatus("reconnecting", true);

        const baseDelay = 500;
        const delay = Math.min(8000, baseDelay * Math.pow(2, Math.min(reconnectAttempt, 4)));
        reconnectAttempt++;

        reconnectTimer = setTimeout(async () => {
            reconnectTimer = null;
            const sid = await ensureReconnectId();
            const alive = await checkSessionAlive(sid);
            if (!alive) {
                reconnecting = false;
                setWsStatus("", false);
                if (confirm("Terminal on server has died, start over?")) {
                    clearReconnectId();
                    location.reload();
                } else {
                    // stop trying; user chose to stay on a dead session
                    explicitClosing = true;
                }
                return;
            }
            connect2server(true);
        }, delay);
    }
    function getTimestampSMS() {
        let now = new Date();
        return now.getSeconds() + now.getMilliseconds() * 0.001;
    }

    function connect2server(isReconnect) {
        hookTouches();
        const c_onmessage = Module.cwrap('onmessage', null, ['array', 'number', 'number', 'number']);
        const chunkState = {
            expected: 0,
            received: 0,
            buffers: []
        };

        const resetChunkState = () => {
            chunkState.expected = 0;
            chunkState.received = 0;
            chunkState.buffers = [];
        };

        const toUint8Array = data => {
            if (data instanceof Uint8Array) return data;
            if (data instanceof ArrayBuffer) return new Uint8Array(data);
            return new Uint8Array(data);
        };

        const handleChunkedMessage = raw => {
            const data = toUint8Array(raw);

            if (chunkState.expected === 0) {
                if (data.length === 4 && data[0] === 0xAB && data[1] === 0xCD) {
                    const totalChunks = (data[2] << 8) | data[3];
                    if (totalChunks <= 0) {
                        console.warn("Received invalid chunk header", data);
                        resetChunkState();
                        return;
                    }
                    chunkState.expected = totalChunks;
                    chunkState.received = 0;
                    chunkState.buffers = [];
                    return;
                }

                c_onmessage(data, data.length, 1, 1);
                return;
            }

            const totalChunks = chunkState.expected;
            const chunkCopy = data.slice();
            chunkState.buffers.push(chunkCopy);
            chunkState.received += 1;
            const currentChunk = chunkState.received;

            if (currentChunk < totalChunks) {
                c_onmessage(chunkCopy, chunkCopy.length, currentChunk, totalChunks);
                return;
            }

            if (currentChunk > totalChunks) {
                console.warn(`Received more chunks (${currentChunk}) than expected (${totalChunks}). Resetting state.`);
                resetChunkState();
                return;
            }

            let totalLength = 0;
            for (const buffer of chunkState.buffers) totalLength += buffer.length;

            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const buffer of chunkState.buffers) {
                combined.set(buffer, offset);
                offset += buffer.length;
            }

            c_onmessage(combined, combined.length, currentChunk, totalChunks);
            resetChunkState();
        };

        (async () => {
            const sid = await ensureReconnectId();
            const wsUrl = terminalDataUrl + `?reconnect=${encodeURIComponent(sid)}`;

            if (websocketWorker) {
                try { websocketWorker.terminate(); } catch (_) {}
            }
            websocketWorker = createWebsocketWorker();

            websocketWorker.postMessage({ command: 'initialize', url: wsUrl });
            websocketWorker.onmessage = e => {
            const msg = e.data;
            const actions = {
                open: () => {
                    console.log("WebSocket connection established via Web Worker.");
                    socket = true;
                    reconnecting = false;
                    setWsStatus("", false);
                    reconnectAttempt = 0;
                },
                sent: () => sent = true,
                message: () => handleChunkedMessage(msg.data),
                error: () => { console.error("WebSocket error:", msg.error); socket = false; resetChunkState(); scheduleReconnect(); },
                close: () => { console.log("WebSocket closed with code:", msg.code); socket = false; resetChunkState(); scheduleReconnect(); }
            };
            actions[msg.event]?.();
            };
        })();
    }

    var dpr = window.devicePixelRatio;
    function isMobile() {
        return /Mobi|Android/i.test(navigator.userAgent);
    }
    if (isMobile()) {
        console.log("Mobile device detected");
        dpr = 1;
    }


    window.addEventListener('resize', js_resizeCanvas, false);
    function js_resizeCanvas() {
        let cc = document.getElementById('canvas');
        cc.width = window.innerWidth * dpr;
        cc.height = window.innerHeight * dpr;
    }

    const appName = "placeholder1";
    const defaultImGUILayoutIni = "placeholder2";

    // Actively close websocket on page unload so server won't wait for reconnect grace.
    window.addEventListener('beforeunload', () => {
        explicitClosing = true;
        try { if (websocketWorker) websocketWorker.postMessage({ command: 'close' }); } catch (_) {}
    });
    window.addEventListener('pagehide', () => {
        explicitClosing = true;
        try { if (websocketWorker) websocketWorker.postMessage({ command: 'close' }); } catch (_) {}
    });

    const canvas = document.getElementById('canvas');
    canvas.addEventListener("webglcontextlost", e => { 
        alert('WebGL context lost. You will need to reload the page.'); 
        e.preventDefault(); 
    }, false);

    var Module = {
        preRun: [], postRun: [], canvas,
        print: function (text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            console.log(text);
        },
        printErr: function (text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            console.error(text);
        }, setStatus: () => {},
        totalDependencies: 0, monitorRunDependencies: () => {}
    };


    (function () {
        function installGLFWPointerPatch() {
            const canvas = (typeof Module !== 'undefined' && Module.canvas) ||
                document.getElementById('canvas') || document.body;

            if (!canvas) { requestAnimationFrame(installGLFWPointerPatch); return; }

            // -------- Config toggles --------
            const ENABLE_PEN_AS_TOUCH = false;      // set true to treat stylus like touch in c_ontouch()
            const DISABLE_LEGACY_TOUCH = true;      // set false if you still want old touch* listeners to run

            // -------- UX hardening --------
            canvas.style.touchAction = 'none';
            canvas.style.userSelect = 'none';
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // ============================================================
            // 1) POINTER CAPTURE FOR MOUSE, BRIDGED TO GLFW MOUSE HANDLERS
            // ============================================================
            canvas.addEventListener('pointerdown', ev => {
                if (ev.pointerType === 'mouse') {
                    try { canvas.setPointerCapture(ev.pointerId); } catch { }
                    // forward as the mousedown GLFW already listens for
                    canvas.dispatchEvent(new MouseEvent('mousedown', {
                        bubbles: true, cancelable: true,
                        clientX: ev.clientX, clientY: ev.clientY,
                        screenX: ev.screenX, screenY: ev.screenY,
                        button: ev.button, buttons: ev.buttons,
                        ctrlKey: ev.ctrlKey, shiftKey: ev.shiftKey,
                        altKey: ev.altKey, metaKey: ev.metaKey
                    }));
                }
            }, { passive: false, capture: true });

            document.addEventListener('pointermove', ev => {
                if (ev.pointerType !== 'mouse' || (ev.buttons | 0) === 0) return;
                const me = new MouseEvent('mousemove', {
                    bubbles: true, cancelable: true,
                    clientX: ev.clientX, clientY: ev.clientY,
                    screenX: ev.screenX, screenY: ev.screenY,
                    button: ev.button, buttons: ev.buttons,
                    ctrlKey: ev.ctrlKey, shiftKey: ev.shiftKey,
                    altKey: ev.altKey, metaKey: ev.metaKey
                });
                // keep deltas if GLFW reads them
                me.movementX = ev.movementX ?? 0;
                me.movementY = ev.movementY ?? 0;
                canvas.dispatchEvent(me);
            }, { passive: true, capture: true });

            document.addEventListener('pointerup', ev => {
                if (ev.pointerType === 'mouse') {
                    try { canvas.releasePointerCapture(ev.pointerId); } catch { }
                    canvas.dispatchEvent(new MouseEvent('mouseup', {
                        bubbles: true, cancelable: true,
                        clientX: ev.clientX, clientY: ev.clientY,
                        screenX: ev.screenX, screenY: ev.screenY,
                        button: ev.button, buttons: ev.buttons,
                        ctrlKey: ev.ctrlKey, shiftKey: ev.shiftKey,
                        altKey: ev.altKey, metaKey: ev.metaKey
                    }));
                }
            }, { passive: true, capture: true });

            canvas.addEventListener('lostpointercapture', () => {
                // safety: ensure GLFW drag state is released
                canvas.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true }));
            }, { capture: true });

            // ===========================================
            // 2) TOUCH VIA POINTER EVENTS -> c_ontouch()
            // ===========================================
            const active = new Map(); // pointerId -> { identifier, x, y }
            const isTouchLike = (ev) =>
                ev.pointerType === 'touch' || (ENABLE_PEN_AS_TOUCH && ev.pointerType === 'pen');

            function emit_c_ontouch() {
                if (typeof c_ontouch !== 'function') return; // no-op if your native hook isn't bound yet
                const touches = Array.from(active.values());
                const caching = new Uint8Array(touches.length * 3 * 4);
                const dv = new DataView(caching.buffer);
                for (let i = 0; i < touches.length; ++i) {
                    dv.setInt32((i * 3 + 0) * 4, touches[i].identifier, true);
                    dv.setInt32((i * 3 + 1) * 4, touches[i].x | 0, true);
                    dv.setInt32((i * 3 + 2) * 4, touches[i].y | 0, true);
                }
                c_ontouch(caching, touches.length);
            }

            function pe_down(ev) {
                if (!isTouchLike(ev)) return;
                ev.preventDefault();
                ev.stopImmediatePropagation();
                try { canvas.setPointerCapture(ev.pointerId); } catch { }
                active.set(ev.pointerId, {
                    identifier: ev.pointerId,
                    x: Math.round(ev.clientX),
                    y: Math.round(ev.clientY)
                });
                emit_c_ontouch();
            }

            function pe_move(ev) {
                if (!isTouchLike(ev)) return;
                if (!active.has(ev.pointerId)) return;
                ev.preventDefault();
                ev.stopImmediatePropagation();
                const t = active.get(ev.pointerId);
                t.x = Math.round(ev.clientX);
                t.y = Math.round(ev.clientY);
                emit_c_ontouch();
            }

            function pe_up_or_cancel(ev) {
                if (!isTouchLike(ev)) return;
                ev.preventDefault();
                ev.stopImmediatePropagation();
                try { canvas.releasePointerCapture(ev.pointerId); } catch { }
                active.delete(ev.pointerId);
                emit_c_ontouch();
            }

            function pe_lost(ev) {
                active.delete(ev.pointerId);
                emit_c_ontouch();
            }

            // pointerdown must hit the capture target
            canvas.addEventListener('pointerdown', pe_down, { passive: false, capture: true });
            // listen on document to survive DOM/leaving element
            document.addEventListener('pointermove', pe_move, { passive: false, capture: true });
            document.addEventListener('pointerup', pe_up_or_cancel, { passive: false, capture: true });
            document.addEventListener('pointercancel', pe_up_or_cancel, { passive: false, capture: true });
            canvas.addEventListener('lostpointercapture', pe_lost, { capture: true });

            // ======================================================
            // 3) OPTIONAL: KILL LEGACY touch* TO AVOID DOUBLE-FIRING
            // ======================================================
            if (DISABLE_LEGACY_TOUCH) {
                const swallow = e => { e.preventDefault(); e.stopImmediatePropagation(); };
                const opts = { passive: false, capture: true };
                document.addEventListener('touchstart', swallow, opts);
                document.addEventListener('touchmove', swallow, opts);
                document.addEventListener('touchend', swallow, opts);
                document.addEventListener('touchcancel', swallow, opts);
            }
        }

        if (typeof Module !== 'undefined') {
            (Module.preRun = Module.preRun || []).push(installGLFWPointerPatch);
        } else {
            window.addEventListener('load', installGLFWPointerPatch);
        }
    })();

        </script>

    <!-- H5 Window -->
	<div class="h5-window" id="h5Window">
	    <div class="h5-window-titlebar" id="h5WindowTitlebar">
	        <div class="h5-window-title">
	            <a class="h5-window-open-new" id="h5WindowOpenNew" target="_blank"></a>
	            <span id="h5WindowTitle" style=" left: 36px; position: relative; ">Web View</span>
	        </div>
	        <div class="h5-window-controls">
	            <button class="h5-window-button" id="h5WindowMinimize">
	                <div class="icon-minimize"></div>
	            </button>
	            <button class="h5-window-button" id="h5WindowMaximize">
	                <div class="icon-maximize"></div>
	            </button>
	            <button class="h5-window-button" id="h5WindowClose">
	                <div class="icon-close"></div>
	            </button>
	        </div>
	    </div>
	    <div class="h5-window-content">
	        <iframe class="h5-window-iframe" id="h5WindowIframe"></iframe>
	    </div>
	    <div class="h5-window-resize-handle n"></div>
	    <div class="h5-window-resize-handle e"></div>
	    <div class="h5-window-resize-handle s"></div>
	    <div class="h5-window-resize-handle w"></div>
	    <div class="h5-window-resize-handle ne"></div>
	    <div class="h5-window-resize-handle se"></div>
	    <div class="h5-window-resize-handle sw"></div>
	    <div class="h5-window-resize-handle nw"></div>
	</div>

    <script>
        // H5 Window functionality
        const h5Window = document.getElementById('h5Window');
        const h5WindowTitlebar = document.getElementById('h5WindowTitlebar');
        const h5WindowIframe = document.getElementById('h5WindowIframe');
        const h5WindowOpenNew = document.getElementById('h5WindowOpenNew');
        const h5WindowTitle = document.getElementById('h5WindowTitle');
        const h5WindowMinimize = document.getElementById('h5WindowMinimize');
        const h5WindowMaximize = document.getElementById('h5WindowMaximize');
        const h5WindowClose = document.getElementById('h5WindowClose');
        const resizeHandles = document.querySelectorAll('.h5-window-resize-handle');

        let isDragging = false;
        let isResizing = false;
        let isMaximized = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        let originalWidth;
        let originalHeight;
        let originalX;
        let originalY;
        let resizeDirection = '';
        let iframeActive = false;

        // Store original dimensions
        function storeOriginalDimensions() {
            originalWidth = h5Window.offsetWidth;
            originalHeight = h5Window.offsetHeight;
            const rect = h5Window.getBoundingClientRect();
            originalX = rect.left;
            originalY = rect.top;
        }

        // Initialize position offsets when window is shown
        function initializePositionOffsets() {
            const rect = h5Window.getBoundingClientRect();
            xOffset = rect.left;
            yOffset = rect.top;
            currentX = xOffset;
            currentY = yOffset;
            initialX = 0;
            initialY = 0;
        }

        // Prevent text selection during resize
        function preventSelection(e) {
            e.preventDefault();
            return false;
        }

        // Resize functionality
        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', initResize);
        });

        function initResize(e) {
            isResizing = true; resizeDirection = e.target.className.split(' ')[1];
            initialX = e.clientX; initialY = e.clientY; storeOriginalDimensions();
            h5WindowIframe.classList.remove('active');
            document.body.style.userSelect = 'none';
            document.addEventListener('selectstart', preventSelection);
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function resize(e) {
            if (!isResizing) return;
            
            e.preventDefault();
            const deltaX = e.clientX - initialX;
            const deltaY = e.clientY - initialY;
            
            let newWidth = originalWidth;
            let newHeight = originalHeight;
            let newX = originalX;
            let newY = originalY;

            // Handle different resize directions
            if (resizeDirection.includes('e')) newWidth = Math.max(200, originalWidth + deltaX);
            if (resizeDirection.includes('w')) {
                const widthDelta = Math.min(deltaX, originalWidth - 200);
                newWidth = originalWidth - widthDelta;
                newX = originalX + widthDelta;
            }
            if (resizeDirection.includes('s')) newHeight = Math.max(150, originalHeight + deltaY);
            if (resizeDirection.includes('n')) {
                const heightDelta = Math.min(deltaY, originalHeight - 150);
                newHeight = originalHeight - heightDelta;
                newY = originalY + heightDelta;
            }

            // Apply new dimensions
            Object.assign(h5Window.style, {
                width: `${newWidth}px`, height: `${newHeight}px`,
                left: `${newX}px`, top: `${newY}px`
            });
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
            document.body.style.userSelect = '';
            document.removeEventListener('selectstart', preventSelection);
            setTimeout(() => iframeActive && h5WindowIframe.classList.add('active'), 100);
        }

        // Existing drag functionality
        h5WindowTitlebar.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (e.target === h5WindowTitlebar || e.target.parentElement === h5WindowTitlebar) {
                isDragging = true;
                
                // Disable iframe interaction during drag
                h5WindowIframe.classList.remove('active');
                
                if (isMaximized) {
                    isMaximized = false;
                    h5Window.style.width = originalWidth + 'px';
                    h5Window.style.height = originalHeight + 'px';
                    h5Window.style.left = originalX + 'px';
                    h5Window.style.top = originalY + 'px';
                    
                    // Re-initialize position after un-maximizing
                    initializePositionOffsets();
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;

                const maxX = window.innerWidth - h5Window.offsetWidth;
                const maxY = window.innerHeight - h5Window.offsetHeight;
                
                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));

                xOffset = currentX;
                yOffset = currentY;
                
                h5Window.style.left = currentX + 'px';
                h5Window.style.top = currentY + 'px';
            }
        }

        function dragEnd(e) {
            if (isDragging) {
                initialX = currentX; initialY = currentY; isDragging = false;
                setTimeout(() => iframeActive && h5WindowIframe.classList.add('active'), 100);
            }
        }

        // Handle iframe focus - use mousedown/up events instead of enter/leave
        h5WindowIframe.addEventListener('mousedown', () => {
            if (!isDragging && !isResizing) {
                iframeActive = true;
                h5WindowIframe.classList.add('active');
            }
        });
        
        document.addEventListener('mousedown', (e) => {
            // If clicking outside the iframe but inside the window content
            if (e.target !== h5WindowIframe && !h5WindowIframe.contains(e.target) && 
                h5Window.contains(e.target) && e.target !== h5WindowTitlebar && 
                !h5WindowTitlebar.contains(e.target) && 
                !e.target.classList.contains('h5-window-resize-handle')) {
                iframeActive = false;
                h5WindowIframe.classList.remove('active');
            }
        });

        h5WindowMinimize.addEventListener('click', () => {
            h5Window.style.display = 'none';
        });

        h5WindowMaximize.addEventListener('click', () => {
            if (!isMaximized) {
                storeOriginalDimensions();
                Object.assign(h5Window.style, {width: '100%', height: '100%', left: '0', top: '0'});
                isMaximized = true;
            } else {
                Object.assign(h5Window.style, {
                    width: originalWidth + 'px', height: originalHeight + 'px',
                    left: originalX + 'px', top: originalY + 'px'
                });
                isMaximized = false;
            }
        });

        h5WindowClose.addEventListener('click', () => {
            h5Window.style.display = 'none';
            isMaximized = false;
        });

        // Function to show H5 window with URL
        window.showH5Window = function(url) {
            Object.assign(h5WindowIframe, {src: url});
            Object.assign(h5WindowOpenNew, {href: url});
            h5WindowTitle.textContent = url;
            h5Window.style.display = 'flex';
            
            if (!isMaximized) Object.assign(h5Window.style, {
                width: '80%', height: '80%', left: '10%', top: '10%', transform: 'none'
            });
            
            setTimeout(() => { initializePositionOffsets(); storeOriginalDimensions(); }, 0);
        };
    </script>
{{{ SCRIPT }}}
</body>
</html>
