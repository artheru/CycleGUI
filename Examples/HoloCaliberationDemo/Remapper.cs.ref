using DetourCore.Debug;
using DetourCore.Misc;
using FundamentalLib.Utilities;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using CycleGUI;
using CycleGUI.API;
using DetourCore.CartDefinition;
using ILGPU.IR.Values;
using static DetourCore.LocatorTypes.LessTagController;
using static DetourCore.LocatorTypes.Remapper;
using DetourCore.UI;
using DetourCore.Types;
using System.Security.Cryptography;

namespace DetourCore.LocatorTypes
{
    [PosSettingsType(Name = "Coordination Remapper", setting = typeof(Remapper), nameDefault = "gnss_map")]
    public class RemapperSettings : Locator.PosSettings
    {
        public string filename = "";
        public int mode = 0; //mode 0: caliberation mode(no output), 1: output mode.

        protected override Locator CreateInstance()
        {
            var lmap = new Remapper() { settings = this, status = "无需启动"};

            D.Log($"Loading remmapping sites for {name}, filename:{filename ?? ""}");
            if (!string.IsNullOrWhiteSpace(filename))
                lmap.load(filename);
            return lmap;
        }
    }

    public class Remapper : Locator
    {
        [StatusMember(Name = "Last Querying X")] public float lastX;
        [StatusMember(Name = "Last Querying Y")] public float lastY;
        [StatusMember(Name = "Last Querying Time")] public DateTime dt;
        [StatusMember(Name = "Remapping info")] public string info="/";

        public RemapperSettings settings;

        public override void Start()
        {
            // nothing to do.

        }

        public class RemapKF : Keyframe
        {
            public override string prefix => "remap_";
            public Remap remap;
            public PutHandleIcon api;

            public void InitAPI()
            {
                api = Workspace.AddProp(new PutHandleIcon()
                {
                    position = new Vector3(remap.map_x / 1000, remap.map_y / 1000, 0),
                    color = Color.Black,
                    bgColor = Color.Wheat,
                    icon = "\uf276",
                    name = $"H_{prefix}{id}",
                });
                DetourUI.NotifyHandleAdded();
            }
        }

        public class Remap
        {
            public float extern_x, extern_y;
            public float map_x, map_y;
        }

        public override UISelection ExtractSelection(string name)
        {
            var selector = $"H_{settings.name}_";
            if (name.StartsWith(selector) && int.TryParse(name.Substring(selector.Length), out int kfId))
            {
                var ss = sites.FirstOrDefault(p => p.id == kfId);
                return new UISelection() { frame = ss, map = this};
            }

            return null;
        }

        public override void Trim()
        {
            foreach (var s in sites)
            {
                if (s.deletionType == 10)
                    s.api.Remove();
            }
            sites.RemoveAll(p => p.deletionType == 10); // todo: maybe use a quicker way, maybe not.
            Delauney(); // Re-triangulate after removing sites
        }

        private bool use_debug;
        const float scale = (float)0.5e4; // Adjust this scale to make extern coordinates visible
        private float test_x, test_y;
        public override void DrawUI(PanelBuilder pb, DetourUI detourUi)
        {
            var selector = $"H_{settings.name}_";
            var sel = detourUi.selection.Where(p => p.map == this).ToArray();
            if (sel.Length > 0)
            {
                if (sel.Count() > 1)
                    pb.Label($"Selected {sel.Count()} places");
                else
                {
                    var ss = (sel[0].frame as RemapKF);
                    pb.Label($"{ss.id} remap ({ss.remap.extern_x},{ss.remap.extern_y})->({ss.remap.map_x},{ss.remap.map_y})");
                }

                pb.Label($"Selected {sel.Count()} places");
            }

            pb.Label($"Map Path={settings.filename}");

            if (pb.Button("Load Map"))
                if (pb.OpenFile("Load Map", "Remapping|*.json", out var loadFn, settings.filename))
                {
                    load(loadFn);
                    pb.Panel.Repaint(true);
                }
             
            if (pb.Button("Save Map"))
                if (pb.SaveFile("Save Map", "Remapping|*.json", out var saveFn, settings.filename))
                {
                    save(saveFn);
                    pb.Panel.Repaint(true);
                }

            if (pb.RadioButtons("Working mode", ["Caliberation", "Output"], ref settings.mode))
                Configuration.ToFile();
            
            pb.Separator();

            // Debug controls for triangulation
            pb.CheckBox("Debug", ref use_debug);
            if (use_debug)
            {
                // if (pb.Button("Show Map Triangulation")) map is never triangulated, only extern is.
                // {
                //     VisualizeTriangulation(false);
                // }
            
                if (pb.Button("Show Extern Triangulation"))
                {
                    VisualizeTriangulation(true);
                }
            
                if (pb.Button("Clear Visualization"))
                {
                    ClearTriangulationVisualization();
                }
            
                pb.DragFloat("test_extern_x", ref test_x, (float)0.001, (float)-1, (float)1);
                pb.DragFloat("test_extern_y", ref test_y, (float)0.001, (float)-1, (float)1);
            
                var (xx, yy, good) = Transform(test_x * 0.002f, test_y * 0.002f);
                pb.Label($"{good}:{xx}, {yy}");
            
                var p = Painter.GetPainter("debug-remapper");
                p.Clear();
                p.DrawDot(Color.White, new Vector3(lastX * scale, lastY * scale, 0), 5);
                p.DrawDot(Color.Orange, new Vector3(xx, yy, 0), 5);
            }

            pb.Separator();
            
            if (pb.Button("Place site here"))
            {
                var remap = new Remap
                {
                    extern_x = lastX,
                    extern_y = lastY,
                    map_x = CartLocation.latest.x,
                    map_y = CartLocation.latest.y
                };
                
                // Check if there's an existing site too close to the new one
                bool replacedExisting = false;
                for (int i = sites.Count - 1; i >= 0; i--)
                {
                    float dx = sites[i].remap.map_x - remap.map_x;
                    float dy = sites[i].remap.map_y - remap.map_y;
                    float distSq = dx * dx + dy * dy;
                    
                    if (distSq < 1000 * 1000)
                    {
                        // Remove the existing site that's too close
                        sites[i].api.Remove();
                        sites.RemoveAt(i);
                        replacedExisting = true;
                    }
                }
                
                // Add the new site
                var kf = new RemapKF() { remap = remap };
                sites.Add(kf);
                kf.InitAPI();

                
                Delauney();
                
                if (replacedExisting)
                {
                    D.Log($"Replaced existing site(s) within 1000 units of new site at ({remap.map_x}, {remap.map_y})");
                }
            }

            pb.Label($"Total {sites.Count} places");
        }

        // Structure to hold triangle vertex indices
        private class TriangleIndices
        {
            public int i1, i2, i3;
            
            public TriangleIndices(int i1, int i2, int i3)
            {
                this.i1 = i1;
                this.i2 = i2;
                this.i3 = i3;
            }
            
            // Override equals and hash code for triangle comparison
            public override bool Equals(object obj)
            {
                if (!(obj is TriangleIndices)) return false;
                var other = (TriangleIndices)obj;
                // Consider triangles with the same vertices equal, regardless of order
                return (i1 == other.i1 || i1 == other.i2 || i1 == other.i3) &&
                       (i2 == other.i1 || i2 == other.i2 || i2 == other.i3) &&
                       (i3 == other.i1 || i3 == other.i2 || i3 == other.i3) &&
                       i1 != i2 && i2 != i3 && i1 != i3;
            }
            
            public override int GetHashCode()
            {
                // Using XOR to make order-independent hash
                return i1 ^ i2 ^ i3;
            }
        }

        private List<TriangleIndices> triangles = new List<TriangleIndices>();

        // Helper function to compute the circumcircle center of a triangle
        private (float x, float y, float radiusSq) ComputeCircumcircle(Remap a, Remap b, Remap c)
        {
            // Using a determinant method to find circle center
            float D = (a.extern_x * (b.extern_y - c.extern_y) +
                       b.extern_x * (c.extern_y - a.extern_y) +
                       c.extern_x * (a.extern_y - b.extern_y)) * 2;
            
            if (Math.Abs(D) < 1e-6) // Collinear points
                return (0, 0, float.MaxValue); // Degenerate case
            
            float x1 = a.extern_x;
            float y1 = a.extern_y;
            float x2 = b.extern_x;
            float y2 = b.extern_y;
            float x3 = c.extern_x;
            float y3 = c.extern_y;
            
            float x1Sq = x1 * x1;
            float y1Sq = y1 * y1;
            float x2Sq = x2 * x2;
            float y2Sq = y2 * y2;
            float x3Sq = x3 * x3;
            float y3Sq = y3 * y3;
            
            float centerX = ((x1Sq + y1Sq) * (y2 - y3) + (x2Sq + y2Sq) * (y3 - y1) + (x3Sq + y3Sq) * (y1 - y2)) / D;
            float centerY = ((x1Sq + y1Sq) * (x3 - x2) + (x2Sq + y2Sq) * (x1 - x3) + (x3Sq + y3Sq) * (x2 - x1)) / D;
            
            // Calculate radius squared (distance from center to any vertex)
            float dx = centerX - x1;
            float dy = centerY - y1;
            float radiusSq = dx * dx + dy * dy;
            
            return (centerX, centerY, radiusSq);
        }

        // Check if a point is inside the circumcircle of a triangle
        private bool IsPointInCircumcircle(Remap point, Remap a, Remap b, Remap c)
        {
            var (centerX, centerY, radiusSq) = ComputeCircumcircle(a, b, c);
            
            float dx = point.extern_x - centerX;
            float dy = point.extern_y - centerY;
            float distanceSq = dx * dx + dy * dy;
            
            return distanceSq < radiusSq;
        }

        // Utility to check if an edge is shared between triangles
        private bool SharesEdge(TriangleIndices t1, TriangleIndices t2)
        {
            int sharedVertices = 0;
            if (t1.i1 == t2.i1 || t1.i1 == t2.i2 || t1.i1 == t2.i3) sharedVertices++;
            if (t1.i2 == t2.i1 || t1.i2 == t2.i2 || t1.i2 == t2.i3) sharedVertices++;
            if (t1.i3 == t2.i1 || t1.i3 == t2.i2 || t1.i3 == t2.i3) sharedVertices++;
            
            return sharedVertices == 2; // Two shared vertices = shared edge
        }

        // Computes the sign of the determinant of vectors AB and AC
        // Used to check if three points make a counterclockwise turn
        private float Cross(Remap a, Remap b, Remap c)
        {
            return (b.extern_x - a.extern_x) * (c.extern_y - a.extern_y) - 
                   (b.extern_y - a.extern_y) * (c.extern_x - a.extern_x);
        }

        // Find a point with minimum X coordinate, with minimum Y as a tiebreaker
        private int FindMinXPoint(List<Remap> points)
        {
            int minIdx = 0;
            for (int i = 1; i < points.Count; i++)
            {
                if (points[i].extern_x < points[minIdx].extern_x ||
                    (Math.Abs(points[i].extern_x - points[minIdx].extern_x) < 1e-6 && 
                     points[i].extern_y < points[minIdx].extern_y))
                {
                    minIdx = i;
                }
            }
            return minIdx;
        }

        // Performs Delaunay triangulation on the 'extern' coordinates of the sites.
        private void Delauney()
        {
            triangles.Clear();
            
            if (sites.Count < 3)
            {
                D.Log($"Need at least 3 sites for Delaunay triangulation, have {sites.Count}");
                return;
            }
            
            // Create a super-triangle that contains all sites
            // First find the bounds of our points
            float minX = sites[0].remap.extern_x;
            float minY = sites[0].remap.extern_y;
            float maxX = minX;
            float maxY = minY;
            
            foreach (var site in sites)
            {
                minX = Math.Min(minX, site.remap.extern_x);
                minY = Math.Min(minY, site.remap.extern_y);
                maxX = Math.Max(maxX, site.remap.extern_x);
                maxY = Math.Max(maxY, site.remap.extern_y);
            }
            
            float dx = maxX - minX;
            float dy = maxY - minY;
            float dmax = Math.Max(dx, dy);
            float midX = (minX + maxX) / 2;
            float midY = (minY + maxY) / 2;
            
            // Add super-triangle vertices to the end of sites temporarily
            int n = sites.Count;
            
            // Create super-triangle vertices (much larger than our actual points)
            var superTri1 = new RemapKF
            {
                id = -1,
                remap = new Remap
                {
                    extern_x = midX - 20 * dmax,
                    extern_y = midY - dmax,
                    map_x = 0, // These don't matter for the triangulation
                    map_y = 0
                }
            };

            var superTri2 = new RemapKF
            {
                id = -2,
                remap = new Remap
                {
                    extern_x = midX,
                    extern_y = midY + 20 * dmax,
                    map_x = 0,
                    map_y = 0
                }
            };

            var superTri3 = new RemapKF
            {
                id = -3,
                remap = new Remap
                {
                    extern_x = midX + 20 * dmax,
                    extern_y = midY - dmax,
                    map_x = 0,
                    map_y = 0
                }
            };
            
            // Add super-triangle to our sites temporarily
            sites.Add(superTri1);
            sites.Add(superTri2);
            sites.Add(superTri3);
            
            // Add the super-triangle to our triangulation
            triangles.Add(new TriangleIndices(n, n+1, n+2));
            
            // Add all sites one by one to the triangulation
            for (int i = 0; i < n; i++)
            {
                // Temporary list to store edges of the "hole" created by removing triangles
                var edges = new List<(int, int)>();
                
                // For each existing triangle, check if site i is inside its circumcircle
                for (int j = triangles.Count - 1; j >= 0; j--)
                {
                    var t = triangles[j];
                    
                    if (IsPointInCircumcircle(sites[i].remap, sites[t.i1].remap, sites[t.i2].remap, sites[t.i3].remap))
                    {
                        // Add edges of the triangle to our list
                        edges.Add((t.i1, t.i2));
                        edges.Add((t.i2, t.i3));
                        edges.Add((t.i3, t.i1));
                        
                        // Remove the triangle
                        triangles.RemoveAt(j);
                    }
                }
                
                // Remove duplicate edges (those that appear twice - inner edges)
                var uniqueEdges = new List<(int, int)>();
                foreach (var edge in edges)
                {
                    // Check if the reversed edge exists (which would make this an inner edge)
                    bool isDuplicate = edges.Any(e => e.Item1 == edge.Item2 && e.Item2 == edge.Item1);
                    
                    if (!isDuplicate)
                        uniqueEdges.Add(edge);
                }
                
                // Create new triangles from the border edges of the hole
                foreach (var edge in uniqueEdges)
                {
                    triangles.Add(new TriangleIndices(edge.Item1, edge.Item2, i));
                }
            }
            
            // Remove triangles that share vertices with the super-triangle
            for (int i = triangles.Count - 1; i >= 0; i--)
            {
                var t = triangles[i];
                if (t.i1 >= n || t.i2 >= n || t.i3 >= n)
                    triangles.RemoveAt(i);
            }
            
            // Remove the super-triangle vertices
            sites.RemoveAt(n + 2);
            sites.RemoveAt(n + 1);
            sites.RemoveAt(n);
            
            D.Log($"Generated {triangles.Count} triangles from {sites.Count} sites.");
        }

        // Helper to calculate cross product (for point-in-triangle check)
        private float CrossProduct(float x1, float y1, float x2, float y2)
        {
            return x1 * y2 - x2 * y1;
        }

        // Check if point (px, py) is inside the triangle defined by vertices a, b, c (using extern coordinates)
        private bool IsPointInTriangle(float px, float py, Remap a, Remap b, Remap c)
        {
            // Using more robust method with cross products to determine point-in-triangle
            
            // Vectors from point to vertices
            float ax = a.extern_x - px;
            float ay = a.extern_y - py;
            
            float bx = b.extern_x - px;
            float by = b.extern_y - py;
            
            float cx = c.extern_x - px;
            float cy = c.extern_y - py;
            
            // Cross products to determine on which side of each edge the point lies
            float crossAB = ax * by - ay * bx;
            float crossBC = bx * cy - by * cx;
            float crossCA = cx * ay - cy * ax;
            
            // Check if all cross products have the same sign (point is inside)
            bool ab = crossAB >= 0;
            bool bc = crossBC >= 0;
            bool ca = crossCA >= 0;
            
            // All same sign = inside
            return (ab == bc) && (bc == ca);
        }

        // Barycentric interpolation
        private (float map_x, float map_y) InterpolateWithinTriangle(float px, float py, Remap r1, Remap r2, Remap r3)
        {
            float x1 = r1.extern_x, y1 = r1.extern_y;
            float x2 = r2.extern_x, y2 = r2.extern_y;
            float x3 = r3.extern_x, y3 = r3.extern_y;

            float den = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3);
            if (Math.Abs(den) < 1e-20) // Avoid division by zero if triangle is degenerate
            {
                 // Fallback: Average of the three points or return closest? Let's average map coords.
                 return ((r1.map_x + r2.map_x + r3.map_x) / 3f, (r1.map_y + r2.map_y + r3.map_y) / 3f);
            }

            float w1 = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / den;
            float w2 = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / den;
            float w3 = 1f - w1 - w2;

            // Clamp weights to avoid issues outside the triangle (though we check first)
            // maybe not, because edge interpolation.
            // w1 = Math.Max(0f, Math.Min(1f, w1));
            // w2 = Math.Max(0f, Math.Min(1f, w2));
            // w3 = Math.Max(0f, Math.Min(1f, w3));
            // Normalize clamped weights if needed (optional, depends on precision needs)
            // float wSum = w1 + w2 + w3; if (wSum > 1e-6) { w1 /= wSum; w2 /= wSum; w3 /= wSum; }


            float map_x = w1 * r1.map_x + w2 * r2.map_x + w3 * r3.map_x;
            float map_y = w1 * r1.map_y + w2 * r2.map_y + w3 * r3.map_y;

            return (map_x, map_y);
        }

        // Finds the two points on the closest triangulation edge to the given point
        private (RemapKF s1, RemapKF s2) FindClosestEdgePoints(float px, float py)
        {
            if (sites.Count <= 1) 
                return sites.Count == 1 ? (sites[0], sites[0]) : (null, null);

            // No triangulation, fall back to closest two points
            if (triangles.Count == 0)
                return FindTwoClosestSites(px, py);

            // First find the closest site to the query point
            RemapKF closestSite = null;
            float minDistSq = float.MaxValue;
            int closestSiteIndex = -1;

            for (int i = 0; i < sites.Count; i++)
            {
                var site = sites[i];
                float dx = site.remap.extern_x - px;
                float dy = site.remap.extern_y - py;
                float distSq = dx * dx + dy * dy;

                if (distSq < minDistSq)
                {
                    minDistSq = distSq;
                    closestSite = site;
                    closestSiteIndex = i;
                }
            }

            if (closestSite == null)
                return (null, null);

            // Vector from closest site to query point
            float queryVectorX = px - closestSite.remap.extern_x;
            float queryVectorY = py - closestSite.remap.extern_y;
            float queryVectorLength = (float)Math.Sqrt(queryVectorX * queryVectorX + queryVectorY * queryVectorY);

            // If query point is very close to closest site, just return the site twice
            if (queryVectorLength < 1e-6f)
                return (closestSite, closestSite);

            // Normalize the query vector
            queryVectorX /= queryVectorLength;
            queryVectorY /= queryVectorLength;

            // Find all edges connected to the closest site
            var connectedEdges = new List<(int siteIndex, float angleCosine)>();

            foreach (var triangle in triangles)
            {
                // Check if this triangle contains the closest site
                bool containsClosestSite = 
                    triangle.i1 == closestSiteIndex || 
                    triangle.i2 == closestSiteIndex || 
                    triangle.i3 == closestSiteIndex;

                if (containsClosestSite)
                {
                    // Add the two edges from closestSite to the other vertices
                    if (triangle.i1 == closestSiteIndex)
                    {
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i2, queryVectorX, queryVectorY);
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i3, queryVectorX, queryVectorY);
                    }
                    else if (triangle.i2 == closestSiteIndex)
                    {
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i1, queryVectorX, queryVectorY);
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i3, queryVectorX, queryVectorY);
                    }
                    else // triangle.i3 == closestSiteIndex
                    {
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i1, queryVectorX, queryVectorY);
                        AddEdgeIfNotExists(connectedEdges, closestSiteIndex, triangle.i2, queryVectorX, queryVectorY);
                    }
                }
            }

            // If no connected edges found (shouldn't happen with valid triangulation), fall back to closest two
            if (connectedEdges.Count == 0)
                return FindTwoClosestSites(px, py);

            // Find the edge most aligned with the query direction (highest cosine value)
            int bestEdgeIndex = 0;
            float bestCosine = connectedEdges[0].angleCosine;

            for (int i = 1; i < connectedEdges.Count; i++)
            {
                if (connectedEdges[i].angleCosine > bestCosine)
                {
                    bestCosine = connectedEdges[i].angleCosine;
                    bestEdgeIndex = i;
                }
            }

            int secondSiteIndex = connectedEdges[bestEdgeIndex].siteIndex;
            return (closestSite, sites[secondSiteIndex]);
        }

        // Helper to add an edge to the connected edges list if not already present
        private void AddEdgeIfNotExists(List<(int siteIndex, float angleCosine)> edges, int fromIndex, int toIndex, float queryVectorX, float queryVectorY)
        {
            // Check if this edge already exists
            if (edges.Any(e => e.siteIndex == toIndex))
                return;

            // Calculate edge vector
            float edgeVectorX = sites[toIndex].remap.extern_x - sites[fromIndex].remap.extern_x;
            float edgeVectorY = sites[toIndex].remap.extern_y - sites[fromIndex].remap.extern_y;
            float edgeLength = (float)Math.Sqrt(edgeVectorX * edgeVectorX + edgeVectorY * edgeVectorY);

            if (edgeLength < 1e-6f)
                return; // Skip degenerate edges

            // Normalize
            edgeVectorX /= edgeLength;
            edgeVectorY /= edgeLength;

            // Calculate cosine of angle between query vector and edge vector
            float cosine = queryVectorX * edgeVectorX + queryVectorY * edgeVectorY;

            edges.Add((toIndex, cosine));
        }

        // Finds the two closest sites to the given point (extern coordinates) - kept as fallback
        private (RemapKF s1, RemapKF s2) FindTwoClosestSites(float px, float py)
        {
            if (sites.Count == 0) return (null, null);
            if (sites.Count == 1) return (sites[0], sites[0]); // Return the same site twice

            RemapKF closest1 = null;
            RemapKF closest2 = null;
            float minDistSq1 = float.MaxValue;
            float minDistSq2 = float.MaxValue;

            foreach (var site in sites)
            {
                float dx = site.remap.extern_x - px;
                float dy = site.remap.extern_y - py;
                float distSq = dx * dx + dy * dy;

                if (distSq < minDistSq1)
                {
                    minDistSq2 = minDistSq1;
                    closest2 = closest1;
                    minDistSq1 = distSq;
                    closest1 = site;
                }
                else if (distSq < minDistSq2)
                {
                    minDistSq2 = distSq;
                    closest2 = site;
                }
            }
            return (closest1, closest2);
        }

        // Interpolate using a continuous approach for points outside the triangulation
        private (float map_x, float map_y) InterpolateOutside(float px, float py, RemapKF s1, RemapKF s2)
        {
            if (s1 == null || s2 == null) return (px, py); // Should not happen if sites exist
            if (s1 == s2) return (s1.remap.map_x, s1.remap.map_y); // Only one site available, return its map coords

            // Find a triangle that contains both s1 and s2 (they should be on an edge)
            int s1Index = sites.IndexOf(s1);
            int s2Index = sites.IndexOf(s2);
            
            if (s1Index < 0 || s2Index < 0)
            {
                D.Log($"Edge vertices not found in sites list, using rigid transform");
                return RigidTransform(px, py, s1.remap, s2.remap);
            }
            
            // Look for a triangle containing both s1 and s2
            foreach (var triangle in triangles)
            {
                bool containsS1 = triangle.i1 == s1Index || triangle.i2 == s1Index || triangle.i3 == s1Index;
                bool containsS2 = triangle.i1 == s2Index || triangle.i2 == s2Index || triangle.i3 == s2Index;
                
                if (containsS1 && containsS2)
                {
                    // Find the third vertex of this triangle
                    int thirdIndex;
                    if (triangle.i1 != s1Index && triangle.i1 != s2Index)
                        thirdIndex = triangle.i1;
                    else if (triangle.i2 != s1Index && triangle.i2 != s2Index)
                        thirdIndex = triangle.i2;
                    else
                        thirdIndex = triangle.i3;
                        
                    RemapKF s3 = sites[thirdIndex];
                    
                    // Use barycentric interpolation with the triangle, but treat the point as if it were on the edge
                    return InterpolateWithinTriangle(px, py, s1.remap, s2.remap, s3.remap);
                }
            }
            
            // If no triangle found containing both points (should be rare, but can happen if the edge is on the convex hull),
            // fall back to rigid transformation
            D.Log($"No triangle found containing edge vertices, using rigid transform");
            return RigidTransform(px, py, s1.remap, s2.remap);
        }

        // Original rigid transform method, renamed and kept as fallback
        private (float map_x, float map_y) RigidTransform(float px, float py, Remap s1, Remap s2)
        {
            // Extern vector (from s1 to s2)
            float ext_dx = s2.extern_x - s1.extern_x;
            float ext_dy = s2.extern_y - s1.extern_y;
            float ext_len_sq = ext_dx * ext_dx + ext_dy * ext_dy;

            // Map vector (from s1 to s2)
            float map_dx = s2.map_x - s1.map_x;
            float map_dy = s2.map_y - s1.map_y;
            float map_len_sq = map_dx * map_dx + map_dy * map_dy;

            // Query vector (from s1 to query point)
            float q_dx = px - s1.extern_x;
            float q_dy = py - s1.extern_y;

            if (ext_len_sq < 1e-10f) // s1 and s2 extern points are coincident
            {
                // Cannot determine scale/rotation. Return s1's map position as a fallback.
                return (s1.map_x, s1.map_y);
            }

            // Calculate scale
            float scale = (float)Math.Sqrt(map_len_sq / ext_len_sq);

            // Calculate rotation using atan2 for better numerical stability
            float angle_ext = (float)Math.Atan2(ext_dy, ext_dx);
            float angle_map = (float)Math.Atan2(map_dy, map_dx);
            float angle_diff = angle_map - angle_ext;
            
            float cosTheta = (float)Math.Cos(angle_diff);
            float sinTheta = (float)Math.Sin(angle_diff);

            // Rotate and scale the query vector
            float q_rotated_scaled_dx = (q_dx * cosTheta - q_dy * sinTheta) * scale;
            float q_rotated_scaled_dy = (q_dx * sinTheta + q_dy * cosTheta) * scale;

            // Translate relative to s1's map position
            float final_map_x = s1.map_x + q_rotated_scaled_dx;
            float final_map_y = s1.map_y + q_rotated_scaled_dy;

            return (final_map_x, final_map_y);
        }

        public (float x, float y, bool use) Transform(float x_i, float y_i)
        {
            dt = DateTime.Now;
            lastX = x_i;
            lastY = y_i;
            info = "no/transform";

            if (settings.mode == 0) // Calibration mode
            {
                return (0, 0, false);
            }

            if (sites.Count < 2) // Need at least 2 sites for any interpolation/extrapolation
            {
                D.Log($"Remapper {settings.name}: Insufficient sites ({sites.Count}) for transformation.");
                info = "insufficient/sites";
                return (x_i, y_i, false);
            }

            // 1. Try Delaunay interpolation
            if (triangles.Count > 0)
            {
                bool anyClose = false;
                foreach (var triIndices in triangles)
                {
                    var r1 = sites[triIndices.i1];
                    var r2 = sites[triIndices.i2];
                    var r3 = sites[triIndices.i3];

                    // even if point is on triangle edge there should be no problem (interpolation is continuous)
                    if (IsPointInTriangle(x_i, y_i, r1.remap, r2.remap, r3.remap))
                    {
                        var (map_x, map_y) = InterpolateWithinTriangle(x_i, y_i, r1.remap, r2.remap, r3.remap);
                        info = $"tr({r1.id}-{r2.id}-{r3.id}):{map_x:0.0},{map_y:0.0}";
                        return (map_x, map_y, true);
                    }
                }
            }
            // If no triangles exist or point is outside all triangles:

            // 2. Extrapolate using the two closest sites
            if (sites.Count >= 2)
            {
                var (s1, s2) = FindClosestEdgePoints(x_i, y_i);
                var (map_x, map_y) = InterpolateOutside(x_i, y_i, s1, s2);
                info = $"edge({s1.id}-{s2.id}):{map_x:0.0},{map_y:0.0}";
                return (map_x, map_y, true); // Still return true, as we performed an extrapolation
            }

            // Should be unreachable if sites.Count >= 2 check passed earlier
            return (x_i, y_i, false);
        }

        List<RemapKF> sites = [];
        public bool load(string filename)
        {
            try
            {
                foreach (var kf in sites)
                    kf.api.Remove();

                sites = (JsonConvert.DeserializeObject<List<Remap>>(File.ReadAllText(filename)) ?? [])
                    .Select(p => new RemapKF() { remap = p }).ToList();

                for (var i = 0; i < sites.Count; i++)
                {
                    var kf = sites[i];
                    kf.InitAPI();
                }

                Delauney();
            }
            catch (Exception ex)
            {
                Diagnosis.Post($"Bad remap file {filename}, ex={ex.FormatEx()}");
            }

            settings.filename = filename;
            return true;
        }

        public void save(string filename)
        {
            File.WriteAllText(filename, JsonConvert.SerializeObject(sites.Select(p => p.remap), Formatting.Indented));
            settings.filename = filename;
            Configuration.ToFile();
        }

        // New method to visualize triangulation for debugging
        private void VisualizeTriangulation(bool useExternCoords)
        {
            // Clear any previous visualization first
            ClearTriangulationVisualization();
            
            if (triangles.Count == 0)
            {
                D.Log("No triangles to visualize");
                return;
            }
            
            int lineCount = 0;
            foreach (var triangle in triangles)
            {
                DrawTriangleEdge(sites[triangle.i1].remap, sites[triangle.i2].remap, lineCount++, useExternCoords);
                DrawTriangleEdge(sites[triangle.i2].remap, sites[triangle.i3].remap, lineCount++, useExternCoords);
                DrawTriangleEdge(sites[triangle.i3].remap, sites[triangle.i1].remap, lineCount++, useExternCoords);
            }

            foreach (var kf in sites)
            {
                Workspace.Prop(new PutStraightLine
                {
                    name = $"tri_edge_{settings.name}_ext_{kf.id}",
                    start = new Vector3(kf.remap.extern_x * scale, kf.remap.extern_y * scale, 0.15f),
                    end = new Vector3(kf.remap.map_x /1000, kf.remap.map_y /1000, 0),
                    width = 1,
                    dashDensity = 2,
                    color = Color.Cyan
                });
            }
            string coordType = useExternCoords ? "extern" : "map";
            D.Log($"Visualized {triangles.Count} triangles ({lineCount} edges) using {coordType} coordinates");
        }

        // Helper to draw a single edge between two sites
        private void DrawTriangleEdge(Remap a, Remap b, int id, bool useExternCoords)
        {
            Vector3 lineStart, lineEnd;
            Color color;
            
            if (useExternCoords)
            {
                // Use extern coordinates and scale them appropriately
                // Scale factor can be adjusted as needed to make them visible in the workspace
                lineStart = new Vector3(a.extern_x * scale, a.extern_y * scale, 0.15f); // Higher Z
                lineEnd = new Vector3(b.extern_x * scale, b.extern_y * scale, 0.15f);
                color = Color.Red; // Use red for extern coordinate triangulation

                Workspace.Prop(new PutStraightLine
                {
                    name = $"tri_edge_{settings.name}_ext_{id}",
                    start = new Vector3(a.extern_x * scale, a.extern_y * scale, 0.15f),
                    end = new Vector3(b.extern_x * scale, b.extern_y * scale, 0.15f),
                    width = 1,
                    dashDensity = 2,
                    color = Color.Red
                });
            }
            else
            {
                // Use map coordinates (as before)
                lineStart = new Vector3(a.map_x / 1000, a.map_y / 1000, 0.1f);
                lineEnd = new Vector3(b.map_x / 1000, b.map_y / 1000, 0.1f);
                color = Color.Yellow; // Use yellow for map coordinate triangulation
            }
            
            string coordType = useExternCoords ? "extern" : "map";
            Workspace.Prop(new PutStraightLine
            {
                name = $"tri_edge_{settings.name}_{coordType}_{id}",
                start = lineStart,
                end = lineEnd,
                width = 1,
                dashDensity = 2,
                color = color
            });
        }

        // Method to clear visualization
        private void ClearTriangulationVisualization()
        {
            WorkspaceProp.RemoveNamePattern($"tri_edge_{settings.name}_*");
        }

        // Helper method to calculate distance from a point to a line segment
        private float DistanceToLine(float px, float py, float x1, float y1, float x2, float y2)
        {
            float A = px - x1;
            float B = py - y1;
            float C = x2 - x1;
            float D = y2 - y1;

            float dot = A * C + B * D;
            float len_sq = C * C + D * D;
            float param = -1;
            
            if (len_sq != 0) // in case of 0 length line
                param = dot / len_sq;

            float xx, yy;

            if (param < 0) 
            {
                xx = x1;
                yy = y1;
            }
            else if (param > 1) 
            {
                xx = x2;
                yy = y2;
            }
            else 
            {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            float dx = px - xx;
            float dy = py - yy;
            return (float)Math.Sqrt(dx * dx + dy * dy);
        }
    }
}
