
        // 2. Show a simple window that we create ourselves. We use a Begin/End pair to create a named window.
        {
            static float f = 0.0f;
            static int counter = 0;

            ImGui::Begin("TEST");
            ImGui::Text("mouse hover: %s, %s, %d", ui_state.mousePointingType.c_str(), ui_state.mousePointingInstance.c_str(), ui_state.mousePointingSubId);
            
            if (ImGui::Button("Set selector=click"))
                SetWorkspaceSelectMode(click);
            ImGui::SameLine(0, 5);
            if (ImGui::Button("drag"))
                SetWorkspaceSelectMode(drag);
            // ImGui::SameLine(0, 5);
            // if (ImGui::Button("drag*"))
            //     SetWorkspaceSelectMode(multi_drag_click);
            ImGui::SameLine(0, 5);
            if (ImGui::Button("painter(r=100)"))
                SetWorkspaceSelectMode(paint, 100);

            static bool loadedsmall = false;
            static float h1 = 0;
            static int n = 0;
            if (ImGui::Button("AddVolatile"))
            {
                AddPointCloud("test", point_cloud{ .isVolatile = true, .capacity = 10000,.initN = 0 });
                SetObjectSubSelectable("test");
                loadedsmall = true;
            }
            if (ImGui::Button("+ point cloud!"))
            {
                point_cloud pc;
                const auto N = 16000;
                glm::vec4 x_y_z_Sz[N / 10];
                uint32_t color[N / 10];
                for (int i = 0; i < N/10; ++i) {
                    int id = i + n;
                    float rho = 3.883222077450933 * (id);
                    float sphi = 1 - 2 * (id + 0.5f) / N;
                    float cphi = std::sqrt(1 - sphi * sphi);
                    float dx = std::cos(rho) * cphi;
                    float dy = std::sin(rho) * cphi;
                    float dz = sphi;
                    x_y_z_Sz[i]=(glm::vec4(dx * 2, dy * 2+2, -dz * 2+1, (5.0 * i) / N + 1));
                    color[i]=(convertColor(glm::vec4(float(n)/N, 1 - float(i) / N, float(i) / N, 1)));
                }
                n += N / 10;
                AppendVolatilePoints("test", N / 10, x_y_z_Sz, color);
                // for (int i = 0; i < N; ++i)
                // {
                //     pc.x_y_z_Sz.push_back(glm::vec4(float(i/100)/40, (i%100)/50.0f, (float)i/1000, 4));
                //     pc.color.push_back(convertColor(glm::vec4(0, 1 - float(i) / N, 1 - float(i) / N, 1)));
                // }
                //AddPointCloud("test", pc);

                // point cloud doesn't support border.
                //SetObjectShine("test", 0xff0000ff);
                //SetObjectSubSelectable("test");
                loadedsmall = true;
            }
            if (ImGui::Button("clear"))
            {
                ClearVolatilePoints("test");
            }
            // if (loadedsmall)
            // {
            //     ImGui::DragFloat("height", &h1, 0.02, -15, 15);
            //     ManipulatePointCloud("test", glm::vec3(0.0f, 0.0f, h1), glm::identity<glm::quat>());
            // }

            static bool test;
            static bool loaded=false;
            static float h = 15;
            // if (ImGui::Button("Load a lot point cloud!"))
            // {
            //     std::ifstream file("D:\\corpus\\static_point_cloud\\geoslam\\Hotel_Southampton.laz.bin", std::ios::binary);
            //
            //     file.seekg(0, std::ios::end);
            //     std::streampos fileSize = file.tellg();
            //     file.seekg(0, std::ios::beg);
            //     int n = fileSize / 32;
            //
            //     point_cloud pc;
            //     pc.x_y_z_Sz.resize(n);
            //     pc.color.resize(n);
            //     for (int i = 0; i < n; i+=1) {
            //         file.read((char*)&pc.x_y_z_Sz[i], 16);
            //         glm::vec4 color;
            //         file.read((char*)& color, 16);
            //         //pc.color[i] = glm::vec4(1.0f);
            //         color /= 65535;
            //         color.a = 1;
            //         pc.color[i] = convertColor(color);
            //     }
            //     pc.position = glm::vec3(0, 0, 15);
            //
            //     file.close();
            //     AddPointCloud("bigpc", pc);
            //     loaded = true;
            //     if (loaded) 
            //     {
            //         ImGui::DragFloat("height", &h, 0.02, -15, 15);
            //         ManipulatePointCloud("bigpc", glm::vec3(0.0f, 0.0f, h), glm::identity<glm::quat>());
            //     }
            // }
            if (ImGui::Button("Load models!"))
            {

                std::ifstream file("xqe.glb", std::ios::binary | std::ios::ate);

                if (!file.is_open()) {
                    std::cerr << "Failed to open the file." << std::endl;
                    return 1;
                }

                // Get the file size
                std::streampos fileSize = file.tellg();
                file.seekg(0, std::ios::beg);

                // Allocate memory for the file content
                unsigned char* buffer = new unsigned char[fileSize];

                // Read the file content into the buffer
                if (!file.read(reinterpret_cast<char*>(buffer), fileSize)) {
                    std::cerr << "Failed to read the file." << std::endl;
                    delete[] buffer;
                    return 1;
                }

                // Close the file
                file.close();

                //LoadModel("flamingo", buffer, fileSize, ModelDetail{ glm::vec3(0,0,0.7), 3 });
                LoadModel("xqe", buffer, fileSize, ModelDetail{ glm::vec3(-1,0,-0.2), glm::angleAxis(glm::radians(180.0f),glm::vec3(1.0f,0.0,0.0)) , 0.001f });
                //LoadModel("xqe", buffer, fileSize, ModelDetail{ glm::vec3(0,0,-5.5), glm::angleAxis(90.0f,glm::vec3(1.0f,0.0,0.0)) ,2 ,0.01f }); // rotate 90 around x is typical.

                PutModelObject("xqe", "xqe1", glm::zero<glm::vec3>(), glm::identity<glm::quat>());
                SetObjectShine("xqe1", 0xffff00ff);
                SetObjectSelectable("xqe1");

                PutModelObject("xqe", "xqe2", glm::vec3(10, 0, 0), glm::angleAxis(glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)));
                //SetObjectBorder("xqe2");
            	SetSubObjectBorderShine("xqe2", 789, false, 0xff0000ff);
                SetObjectSubSelectable("xqe2");
            }
            if (ImGui::Button("Many"))
            {
                for (int i = 0; i < 100; ++i) {
                    float angle = glm::linearRand(0.0f, glm::two_pi<float>());

                    // Create a quaternion that rotates around the z-axis
                    glm::quat rotationQuat = glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f));

                    // Generate a random vec2 in the XY plane
                    glm::vec2 randomVec2 = glm::diskRand(50.0f);
                    PutModelObject("xqe", std::format("f{}",i).c_str(), glm::vec3(randomVec2,0), rotationQuat);
                }
            }
            ImGui::Text("ðŸ–This is some useful text.ä»¥åŠæ±‰å­—, I1l, 0Oo");               // Display some text (you can use a format strings too)
            ImGui::Text(std::format("stare={},{},{}", camera->stare[0], camera->stare[1], camera->stare[2]).c_str());
            ImGui::Text(std::format("pos={},{},{}", camera->position[0], camera->position[1], camera->position[2]).c_str());

        	ImGui::Text(ICON_FK_ADDRESS_BOOK" TEST FK");
            ImGui::Checkbox("Demo Window", &show_demo_window);      // Edit bools storing our window open/close state
            ImGui::Checkbox("Another Window", &show_another_window);
            ToggleButton("è¯•ä¸€è¯•å‘€", &test);
            ImGui::SliderFloat("float", &f, 0.0f, 1.0f);            // Edit 1 float using a slider from 0.0f to 1.0f
            ImGui::ColorEdit3("clear color", (float*)&clear_color); // Edit 3 floats representing a color

            if (ImGui::Button("Button"))                            // Buttons return true when clicked (most widgets return true when edited/activated)
                counter++;
            ImGui::SameLine();
            ImGui::Text("counter = %d", counter);

            ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
            ImGui::End();
        }
